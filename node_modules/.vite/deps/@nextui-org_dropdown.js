"use client";
import {
  $453cc9f0df89c0a5$export$77d5aafae4e095b2,
  $7613b1592d41b092$export$6cd28814d92fa9c9,
  $9fc4852771d079eb$export$6e2c8f0811a474ce,
  $c1d7fb2ec91bae71$export$6d08773d2e66f8f2,
  $fc909762b330b746$export$61c6a8c84e605fb6,
  ariaHideOutside,
  getArrowPlacement,
  getShouldUseAxisPlacement,
  getTransformOrigins,
  toReactAriaPlacement
} from "./chunk-7Y54OQGT.js";
import {
  button_default
} from "./chunk-HJMK54SE.js";
import {
  useSafeLayoutEffect
} from "./chunk-MAUXY7IL.js";
import {
  TRANSITION_VARIANTS
} from "./chunk-RI2VY2CS.js";
import {
  useAriaButton
} from "./chunk-PVFMUZKO.js";
import {
  $18f2051aff69b9bf$export$43bb16f9c6d9e3f7,
  $2a41e45df1593e64$export$d39e1813b3bdd0e1,
  $325a3faab7a68acd$export$a16aca283550c30d,
  $337b884510726a0d$export$14c98a7594375490,
  $337b884510726a0d$export$c6fdb837b070b4ff,
  $49c51c25361d4cd2$export$ee0f7cc6afcd1c18,
  $628037886ba31236$export$f9d5c8beee7d008d,
  $6a99195332edec8b$export$80f3e147d781571c,
  $86ea4cb521eb2e37$export$2317d149ed6f78c4,
  $9bf71ea28793e738$export$1258395f99bf9cbf,
  $9bf71ea28793e738$export$20e40289641fbbb6,
  $9bf71ea28793e738$export$2d6ec8fc375ceafa,
  $f7dceffc5ad7768b$export$4e328f61c538687f,
  $fca6afa0e843324b$export$f12b703ca79dfbb1,
  AnimatePresence,
  LazyMotion,
  createContext2,
  domAnimation,
  filterDOMProps,
  m,
  mergeRefs,
  pickChildren,
  useDOMRef,
  useProviderContext
} from "./chunk-EKSMO5VP.js";
import {
  $2f04cbc44ee30ce0$export$53a0910f038337bd,
  $2f04cbc44ee30ce0$export$c826860796309d1b,
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $458b0a5536c1a7cf$export$40bfa8c7b0832715,
  $46d819fcbaf35654$export$8f71654801c2f7cd,
  $507fabe10e71c6fb$export$630ff653c5ada6a9,
  $507fabe10e71c6fb$export$b9b3dfddab17db27,
  $5dc95899b306f630$export$c9058316764c140e,
  $6179b936705e76d3$export$ae780daf29e6d456,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f,
  $7215afc6de606d6b$export$de79e2c695e052f3,
  $8a26561d2877236e$export$c24ed0104d07eab9,
  $9ab94262bd0047c7$export$420e68273165f4ec,
  $a1ea59d68270f0dd$export$f8168d8dd8fd66e6,
  $bdb11010cef70236$export$b4cc09c592e8fdb8,
  $bdb11010cef70236$export$f680877a34711e37,
  $c87311424ea30a05$export$9ac100e40613ea10,
  $c87311424ea30a05$export$e1865c3bedcd822b,
  $cc38e7bd3fc7b213$export$2bb74740c4e19def,
  $e0b6e0b68ec7f50f$export$872b660ac5a1ff98,
  $e9faafb641e167db$export$90fc3a17d93f704c,
  $ea8dcbcb9ea1b556$export$7e924b3091a3bd18,
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7,
  $ea8dcbcb9ea1b556$export$9a302a45f65d0572,
  $f6c31cce2adf654f$export$45712eceda6fad21,
  $ff5963eb1fccf552$export$e08e3b67e392101e
} from "./chunk-64U3YG7S.js";
import "./chunk-U7P2NEEE.js";
import {
  require_react_dom
} from "./chunk-M7F2YF5A.js";
import {
  clsx,
  dataAttr,
  forwardRef,
  mapPropsVariants,
  objectToDeps,
  removeEvents
} from "./chunk-I7HNNRHT.js";
import {
  require_jsx_runtime
} from "./chunk-WLVB5OIP.js";
import {
  divider,
  dropdown,
  menu,
  menuItem,
  menuSection,
  popover
} from "./chunk-FQE3ZJE3.js";
import "./chunk-QE3KPBPK.js";
import {
  require_react
} from "./chunk-CANBAPAS.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@nextui-org/dropdown/dist/chunk-WRRPXIUB.mjs
var [DropdownProvider, useDropdownContext] = createContext2({
  name: "DropdownContext",
  errorMessage: "useDropdownContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Dropdown />`"
});

// node_modules/@nextui-org/popover/dist/chunk-Z3P7GO4G.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@nextui-org/use-aria-overlay/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var visibleOverlays = [];
function useAriaOverlay(props, ref) {
  const {
    disableOutsideEvents = true,
    isDismissable = false,
    isKeyboardDismissDisabled = false,
    isOpen,
    onClose,
    shouldCloseOnBlur,
    shouldCloseOnInteractOutside
  } = props;
  (0, import_react.useEffect)(() => {
    if (isOpen) {
      visibleOverlays.push(ref);
    }
    return () => {
      const index = visibleOverlays.indexOf(ref);
      if (index >= 0) {
        visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]);
  const onHide = () => {
    if (visibleOverlays[visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  };
  const onInteractOutsideStart = (e) => {
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
      if (visibleOverlays[visibleOverlays.length - 1] === ref) {
        if (disableOutsideEvents) {
          e.stopPropagation();
          e.preventDefault();
        }
      }
      if (e.pointerType !== "touch") {
        onHide();
      }
    }
  };
  const onInteractOutside = (e) => {
    if (e.pointerType !== "touch") {
      return;
    }
    if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {
      if (visibleOverlays[visibleOverlays.length - 1] === ref) {
        if (disableOutsideEvents) {
          e.stopPropagation();
          e.preventDefault();
        }
      }
      onHide();
    }
  };
  const onKeyDown = (e) => {
    if (e.key === "Escape" && !isKeyboardDismissDisabled && !e.nativeEvent.isComposing) {
      e.stopPropagation();
      e.preventDefault();
      onHide();
    }
  };
  $e0b6e0b68ec7f50f$export$872b660ac5a1ff98({
    isDisabled: !(isDismissable && isOpen),
    onInteractOutside,
    onInteractOutsideStart,
    ref
  });
  const { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: (e) => {
      if (!e.relatedTarget || $9bf71ea28793e738$export$1258395f99bf9cbf(e.relatedTarget)) {
        return;
      }
      if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget)) {
        onHide();
      }
    }
  });
  const onPointerDownUnderlay = (e) => {
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };
  return {
    overlayProps: {
      onKeyDown,
      ...focusWithinProps
    },
    underlayProps: {
      onPointerDown: onPointerDownUnderlay
    }
  };
}

// node_modules/@nextui-org/popover/dist/chunk-Z3P7GO4G.mjs
function useReactAriaPopover(props, state) {
  const {
    triggerRef,
    popoverRef,
    showArrow,
    offset = 7,
    crossOffset = 0,
    scrollRef,
    shouldFlip,
    boundaryElement,
    isDismissable = true,
    shouldCloseOnBlur = true,
    placement: placementProp = "top",
    containerPadding,
    shouldCloseOnInteractOutside,
    isNonModal: isNonModalProp,
    isKeyboardDismissDisabled,
    updatePositionDeps = [],
    ...otherProps
  } = props;
  const isNonModal = isNonModalProp != null ? isNonModalProp : true;
  const { overlayProps, underlayProps } = useAriaOverlay(
    {
      isOpen: state.isOpen,
      onClose: state.close,
      shouldCloseOnBlur,
      isDismissable,
      isKeyboardDismissDisabled,
      shouldCloseOnInteractOutside: shouldCloseOnInteractOutside || ((el) => {
        var _a;
        return !((_a = triggerRef.current) == null ? void 0 : _a.contains(el));
      }),
      disableOutsideEvents: !isNonModal
    },
    popoverRef
  );
  const {
    overlayProps: positionProps,
    arrowProps,
    placement,
    updatePosition
  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({
    ...otherProps,
    shouldFlip,
    crossOffset,
    targetRef: triggerRef,
    overlayRef: popoverRef,
    isOpen: state.isOpen,
    scrollRef,
    boundaryElement,
    containerPadding,
    placement: toReactAriaPlacement(placementProp),
    offset: showArrow ? offset + 3 : offset,
    onClose: isNonModal ? state.close : () => {
    }
  });
  useSafeLayoutEffect(() => {
    if (!updatePositionDeps.length)
      return;
    updatePosition();
  }, updatePositionDeps);
  (0, import_react2.useEffect)(() => {
    if (state.isOpen && !isNonModal && popoverRef.current) {
      return ariaHideOutside([popoverRef.current]);
    }
  }, [isNonModal, state.isOpen, popoverRef]);
  return {
    popoverProps: $3ef42575df84b30b$export$9d1611c77c2fe928(overlayProps, positionProps),
    arrowProps,
    underlayProps,
    placement
  };
}

// node_modules/@nextui-org/popover/dist/chunk-HWCD2GH5.mjs
var import_react3 = __toESM(require_react(), 1);
function usePopover(originalProps) {
  var _a, _b, _c;
  const globalContext = useProviderContext();
  const [props, variantProps] = mapPropsVariants(originalProps, popover.variantKeys);
  const {
    as,
    ref,
    children,
    state: stateProp,
    triggerRef: triggerRefProp,
    scrollRef,
    defaultOpen,
    onOpenChange,
    isOpen: isOpenProp,
    isNonModal = true,
    shouldFlip = true,
    containerPadding = 12,
    shouldBlockScroll = false,
    isDismissable = true,
    shouldCloseOnBlur,
    portalContainer,
    updatePositionDeps,
    dialogProps: dialogPropsProp,
    placement: placementProp = "top",
    triggerType = "dialog",
    showArrow = false,
    offset = 7,
    crossOffset = 0,
    boundaryElement,
    isKeyboardDismissDisabled,
    shouldCloseOnInteractOutside,
    motionProps,
    className,
    classNames,
    onClose,
    ...otherProps
  } = props;
  const Component = as || "div";
  const domRef = useDOMRef(ref);
  const domTriggerRef = (0, import_react3.useRef)(null);
  const wasTriggerPressedRef = (0, import_react3.useRef)(false);
  const triggerRef = triggerRefProp || domTriggerRef;
  const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
  const innerState = $fc909762b330b746$export$61c6a8c84e605fb6({
    isOpen: isOpenProp,
    defaultOpen,
    onOpenChange: (isOpen) => {
      onOpenChange == null ? void 0 : onOpenChange(isOpen);
      if (!isOpen) {
        onClose == null ? void 0 : onClose();
      }
    }
  });
  const state = stateProp || innerState;
  const {
    popoverProps,
    underlayProps,
    placement: ariaPlacement
  } = useReactAriaPopover(
    {
      triggerRef,
      isNonModal,
      popoverRef: domRef,
      placement: placementProp,
      offset,
      scrollRef,
      isDismissable,
      shouldCloseOnBlur,
      boundaryElement,
      crossOffset,
      shouldFlip,
      containerPadding,
      updatePositionDeps,
      isKeyboardDismissDisabled,
      shouldCloseOnInteractOutside
    },
    state
  );
  const { triggerProps } = $628037886ba31236$export$f9d5c8beee7d008d({ type: triggerType }, state, triggerRef);
  const { isFocusVisible, isFocused, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f();
  const slots = (0, import_react3.useMemo)(
    () => popover({
      ...variantProps
    }),
    [objectToDeps(variantProps)]
  );
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  const getPopoverProps = (props2 = {}) => ({
    ref: domRef,
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(popoverProps, otherProps, props2),
    style: $3ef42575df84b30b$export$9d1611c77c2fe928(popoverProps.style, otherProps.style, props2.style)
  });
  const getDialogProps = (props2 = {}) => ({
    "data-slot": "base",
    "data-open": dataAttr(state.isOpen),
    "data-focus": dataAttr(isFocused),
    "data-arrow": dataAttr(showArrow),
    "data-focus-visible": dataAttr(isFocusVisible),
    "data-placement": getArrowPlacement(ariaPlacement, placementProp),
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(focusProps, dialogPropsProp, props2),
    className: slots.base({ class: clsx(baseStyles) }),
    style: {
      outline: "none"
    }
  });
  const getContentProps = (0, import_react3.useCallback)(
    (props2 = {}) => ({
      "data-slot": "content",
      "data-open": dataAttr(state.isOpen),
      "data-arrow": dataAttr(showArrow),
      "data-placement": getArrowPlacement(ariaPlacement, placementProp),
      className: slots.content({ class: clsx(classNames == null ? void 0 : classNames.content, props2.className) })
    }),
    [slots, state.isOpen, showArrow, ariaPlacement, placementProp, classNames]
  );
  const placement = (0, import_react3.useMemo)(
    () => getShouldUseAxisPlacement(ariaPlacement, placementProp) ? ariaPlacement || placementProp : placementProp,
    [ariaPlacement, placementProp]
  );
  const onPress = (0, import_react3.useCallback)(
    (e) => {
      var _a2;
      let pressTimer;
      if (e.pointerType === "touch" && ((originalProps == null ? void 0 : originalProps.backdrop) === "blur" || (originalProps == null ? void 0 : originalProps.backdrop) === "opaque")) {
        pressTimer = setTimeout(() => {
          wasTriggerPressedRef.current = true;
        }, 100);
      } else {
        wasTriggerPressedRef.current = true;
      }
      (_a2 = triggerProps.onPress) == null ? void 0 : _a2.call(triggerProps, e);
      return () => {
        clearTimeout(pressTimer);
      };
    },
    [triggerProps == null ? void 0 : triggerProps.onPress]
  );
  const getTriggerProps = (0, import_react3.useCallback)(
    (props2 = {}, _ref = null) => {
      const { isDisabled, ...otherProps2 } = props2;
      return {
        "data-slot": "trigger",
        ...$3ef42575df84b30b$export$9d1611c77c2fe928({ "aria-haspopup": "dialog" }, triggerProps, otherProps2),
        onPress,
        isDisabled,
        className: slots.trigger({
          class: clsx(classNames == null ? void 0 : classNames.trigger, props2.className),
          isTriggerDisabled: isDisabled
        }),
        ref: $5dc95899b306f630$export$c9058316764c140e(_ref, triggerRef)
      };
    },
    [state, triggerProps, onPress, triggerRef]
  );
  const getBackdropProps = (0, import_react3.useCallback)(
    (props2 = {}) => ({
      "data-slot": "backdrop",
      className: slots.backdrop({ class: classNames == null ? void 0 : classNames.backdrop }),
      onClick: (e) => {
        if (!wasTriggerPressedRef.current) {
          e.preventDefault();
          return;
        }
        state.close();
        wasTriggerPressedRef.current = false;
      },
      ...underlayProps,
      ...props2
    }),
    [slots, state.isOpen, classNames, underlayProps]
  );
  $49c51c25361d4cd2$export$ee0f7cc6afcd1c18({
    isDisabled: !(shouldBlockScroll && state.isOpen)
  });
  return {
    state,
    Component,
    children,
    classNames,
    showArrow,
    triggerRef,
    placement,
    isNonModal,
    popoverRef: domRef,
    portalContainer,
    isOpen: state.isOpen,
    onClose: state.close,
    disableAnimation,
    backdrop: (_c = originalProps.backdrop) != null ? _c : "transparent",
    motionProps,
    getBackdropProps,
    getPopoverProps,
    getTriggerProps,
    getDialogProps,
    getContentProps
  };
}

// node_modules/@nextui-org/popover/dist/chunk-6NWALNDX.mjs
var React = __toESM(require_react(), 1);

// node_modules/@react-aria/dialog/dist/useDialog.mjs
var import_react4 = __toESM(require_react(), 1);
function $40df3f8667284809$export$d55e7ee900f34e93(props, ref) {
  let { role = "dialog" } = props;
  let titleId = (0, $bdb11010cef70236$export$b4cc09c592e8fdb8)();
  titleId = props["aria-label"] ? void 0 : titleId;
  let isRefocusing = (0, import_react4.useRef)(false);
  (0, import_react4.useEffect)(() => {
    if (ref.current && !ref.current.contains(document.activeElement)) {
      (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
      let timeout = setTimeout(() => {
        if (document.activeElement === ref.current) {
          isRefocusing.current = true;
          if (ref.current) {
            ref.current.blur();
            (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
          }
          isRefocusing.current = false;
        }
      }, 500);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [
    ref
  ]);
  (0, $337b884510726a0d$export$14c98a7594375490)();
  return {
    dialogProps: {
      ...(0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
        labelable: true
      }),
      role,
      tabIndex: -1,
      "aria-labelledby": props["aria-labelledby"] || titleId,
      // Prevent blur events from reaching useOverlay, which may cause
      // popovers to close. Since focus is contained within the dialog,
      // we don't want this to occur due to the above useEffect.
      onBlur: (e) => {
        if (isRefocusing.current) e.stopPropagation();
      }
    },
    titleProps: {
      id: titleId
    }
  };
}

// node_modules/@nextui-org/popover/dist/chunk-6NWALNDX.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var FreeSoloPopoverWrapper = forwardRef(
  ({
    children,
    motionProps,
    placement,
    disableAnimation,
    style: styleProp = {},
    transformOrigin = {},
    ...otherProps
  }, ref) => {
    let style = styleProp;
    if (transformOrigin.originX !== void 0 || transformOrigin.originY !== void 0) {
      style = {
        ...style,
        transformOrigin
      };
    } else {
      style = {
        ...style,
        ...getTransformOrigins(placement === "center" ? "top" : placement)
      };
    }
    return disableAnimation ? (0, import_jsx_runtime.jsx)("div", { ...otherProps, ref, children }) : (0, import_jsx_runtime.jsx)(LazyMotion, { features: domAnimation, children: (0, import_jsx_runtime.jsx)(
      m.div,
      {
        ref,
        animate: "enter",
        exit: "exit",
        initial: "initial",
        style,
        variants: TRANSITION_VARIANTS.scaleSpringOpacity,
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(otherProps, motionProps),
        children
      }
    ) });
  }
);
FreeSoloPopoverWrapper.displayName = "NextUI.FreeSoloPopoverWrapper";
var FreeSoloPopover = forwardRef(
  ({ children, transformOrigin, disableDialogFocus = false, ...props }, ref) => {
    const {
      Component,
      state,
      placement,
      backdrop,
      portalContainer,
      disableAnimation,
      motionProps,
      isNonModal,
      getPopoverProps,
      getBackdropProps,
      getDialogProps,
      getContentProps
    } = usePopover({
      ...props,
      ref
    });
    const dialogRef = React.useRef(null);
    const { dialogProps: ariaDialogProps, titleProps } = $40df3f8667284809$export$d55e7ee900f34e93({}, dialogRef);
    const dialogProps = getDialogProps({
      ...!disableDialogFocus && { ref: dialogRef },
      ...ariaDialogProps
    });
    const backdropContent = React.useMemo(() => {
      if (backdrop === "transparent") {
        return null;
      }
      if (disableAnimation) {
        return (0, import_jsx_runtime.jsx)("div", { ...getBackdropProps() });
      }
      return (0, import_jsx_runtime.jsx)(LazyMotion, { features: domAnimation, children: (0, import_jsx_runtime.jsx)(
        m.div,
        {
          animate: "enter",
          exit: "exit",
          initial: "exit",
          variants: TRANSITION_VARIANTS.fade,
          ...getBackdropProps()
        }
      ) });
    }, [backdrop, disableAnimation, getBackdropProps]);
    return (0, import_jsx_runtime.jsxs)($337b884510726a0d$export$c6fdb837b070b4ff, { portalContainer, children: [
      !isNonModal && backdropContent,
      (0, import_jsx_runtime.jsx)(Component, { ...getPopoverProps(), children: (0, import_jsx_runtime.jsxs)(
        FreeSoloPopoverWrapper,
        {
          disableAnimation,
          motionProps,
          placement,
          tabIndex: -1,
          transformOrigin,
          ...dialogProps,
          children: [
            !isNonModal && (0, import_jsx_runtime.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: state.close }),
            (0, import_jsx_runtime.jsx)("div", { ...getContentProps(), children: typeof children === "function" ? children(titleProps) : children }),
            (0, import_jsx_runtime.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: state.close })
          ]
        }
      ) })
    ] });
  }
);
FreeSoloPopover.displayName = "NextUI.FreeSoloPopover";

// node_modules/@nextui-org/popover/dist/chunk-SQ3I4X62.mjs
var [PopoverProvider, usePopoverContext] = createContext2({
  name: "PopoverContext",
  errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
});

// node_modules/@nextui-org/popover/dist/chunk-3KHBFE7C.mjs
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var PopoverContent = forwardRef((props, _) => {
  const { as, children, className, ...otherProps } = props;
  const {
    Component: OverlayComponent,
    placement,
    backdrop,
    motionProps,
    disableAnimation,
    getPopoverProps,
    getDialogProps,
    getBackdropProps,
    getContentProps,
    isNonModal,
    onClose
  } = usePopoverContext();
  const dialogRef = (0, import_react5.useRef)(null);
  const { dialogProps: ariaDialogProps, titleProps } = $40df3f8667284809$export$d55e7ee900f34e93({}, dialogRef);
  const dialogProps = getDialogProps({
    ref: dialogRef,
    ...ariaDialogProps,
    ...otherProps
  });
  const Component = as || OverlayComponent || "div";
  const content = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    !isNonModal && (0, import_jsx_runtime2.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: onClose }),
    (0, import_jsx_runtime2.jsx)(Component, { ...dialogProps, children: (0, import_jsx_runtime2.jsx)("div", { ...getContentProps({ className }), children: typeof children === "function" ? children(titleProps) : children }) }),
    (0, import_jsx_runtime2.jsx)($86ea4cb521eb2e37$export$2317d149ed6f78c4, { onDismiss: onClose })
  ] });
  const backdropContent = (0, import_react5.useMemo)(() => {
    if (backdrop === "transparent") {
      return null;
    }
    if (disableAnimation) {
      return (0, import_jsx_runtime2.jsx)("div", { ...getBackdropProps() });
    }
    return (0, import_jsx_runtime2.jsx)(LazyMotion, { features: domAnimation, children: (0, import_jsx_runtime2.jsx)(
      m.div,
      {
        animate: "enter",
        exit: "exit",
        initial: "exit",
        variants: TRANSITION_VARIANTS.fade,
        ...getBackdropProps()
      }
    ) });
  }, [backdrop, disableAnimation, getBackdropProps]);
  const contents = disableAnimation ? content : (0, import_jsx_runtime2.jsx)(LazyMotion, { features: domAnimation, children: (0, import_jsx_runtime2.jsx)(
    m.div,
    {
      animate: "enter",
      exit: "exit",
      initial: "initial",
      style: {
        ...getTransformOrigins(placement === "center" ? "top" : placement)
      },
      variants: TRANSITION_VARIANTS.scaleSpringOpacity,
      ...motionProps,
      children: content
    }
  ) });
  return (0, import_jsx_runtime2.jsxs)("div", { ...getPopoverProps(), children: [
    backdropContent,
    contents
  ] });
});
PopoverContent.displayName = "NextUI.PopoverContent";
var popover_content_default = PopoverContent;

// node_modules/@nextui-org/popover/dist/chunk-HGSZQ3PO.mjs
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var PopoverTrigger = forwardRef((props, _) => {
  const { triggerRef, getTriggerProps } = usePopoverContext();
  const { children, ...otherProps } = props;
  const child = (0, import_react6.useMemo)(() => {
    if (typeof children === "string")
      return (0, import_jsx_runtime3.jsx)("p", { children });
    return import_react6.Children.only(children);
  }, [children]);
  const { onPress, isDisabled, ...restProps } = (0, import_react6.useMemo)(() => {
    return getTriggerProps($3ef42575df84b30b$export$9d1611c77c2fe928(otherProps, child.props), child.ref);
  }, [getTriggerProps, child.props, otherProps, child.ref]);
  const [, triggerChildren] = pickChildren(children, button_default);
  const { buttonProps } = useAriaButton({ onPress, isDisabled }, triggerRef);
  const hasNextUIButton = (0, import_react6.useMemo)(() => {
    return (triggerChildren == null ? void 0 : triggerChildren[0]) !== void 0;
  }, [triggerChildren]);
  return (0, import_react6.cloneElement)(
    child,
    $3ef42575df84b30b$export$9d1611c77c2fe928(restProps, hasNextUIButton ? { onPress, isDisabled } : buttonProps)
  );
});
PopoverTrigger.displayName = "NextUI.PopoverTrigger";
var popover_trigger_default = PopoverTrigger;

// node_modules/@nextui-org/popover/dist/chunk-54SXDOOT.mjs
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var Popover = forwardRef((props, ref) => {
  const { children, ...otherProps } = props;
  const context = usePopover({ ...otherProps, ref });
  const [trigger, content] = import_react7.Children.toArray(children);
  const overlay = (0, import_jsx_runtime4.jsx)($337b884510726a0d$export$c6fdb837b070b4ff, { portalContainer: context.portalContainer, children: content });
  return (0, import_jsx_runtime4.jsxs)(PopoverProvider, { value: context, children: [
    trigger,
    context.disableAnimation && context.isOpen ? overlay : (0, import_jsx_runtime4.jsx)(AnimatePresence, { children: context.isOpen ? overlay : null })
  ] });
});
Popover.displayName = "NextUI.Popover";
var popover_default = Popover;

// node_modules/@nextui-org/menu/dist/chunk-EEKZGUSR.mjs
var MenuSectionBase = $9fc4852771d079eb$export$6e2c8f0811a474ce;
var menu_section_base_default = MenuSectionBase;

// node_modules/@nextui-org/menu/dist/chunk-7C7K3AST.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function MenuSelectedIcon(props) {
  const { isSelected, disableAnimation, ...otherProps } = props;
  return (0, import_jsx_runtime5.jsx)(
    "svg",
    {
      "aria-hidden": "true",
      "data-selected": isSelected,
      role: "presentation",
      viewBox: "0 0 17 18",
      ...otherProps,
      children: (0, import_jsx_runtime5.jsx)(
        "polyline",
        {
          fill: "none",
          points: "1 9 7 14 15 4",
          stroke: "currentColor",
          strokeDasharray: 22,
          strokeDashoffset: isSelected ? 44 : 66,
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: 1.5,
          style: !disableAnimation ? {
            transition: "stroke-dashoffset 200ms ease"
          } : {}
        }
      )
    }
  );
}

// node_modules/@nextui-org/menu/dist/chunk-BQCSFB47.mjs
var import_react13 = __toESM(require_react(), 1);

// node_modules/@react-aria/selection/dist/utils.mjs
function $feb5ffebff200149$export$d3e3bd3e26688c04(e) {
  return (0, $c87311424ea30a05$export$e1865c3bedcd822b)() ? e.altKey : e.ctrlKey;
}
function $feb5ffebff200149$export$16792effe837dba3(e) {
  if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) return e.metaKey;
  return e.ctrlKey;
}

// node_modules/@react-aria/selection/dist/useTypeSelect.mjs
var import_react8 = __toESM(require_react(), 1);
var $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS = 1e3;
function $fb3050f43d946246$export$e32c88dfddc6e1d8(options) {
  let { keyboardDelegate, selectionManager, onTypeSelect } = options;
  let state = (0, import_react8.useRef)({
    search: "",
    timeout: null
  }).current;
  let onKeyDown = (e) => {
    let character = $fb3050f43d946246$var$getStringForKey(e.key);
    if (!character || e.ctrlKey || e.metaKey || !e.currentTarget.contains(e.target)) return;
    if (character === " " && state.search.trim().length > 0) {
      e.preventDefault();
      if (!("continuePropagation" in e)) e.stopPropagation();
    }
    state.search += character;
    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);
    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);
    if (key != null) {
      selectionManager.setFocusedKey(key);
      if (onTypeSelect) onTypeSelect(key);
    }
    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = "";
    }, $fb3050f43d946246$var$TYPEAHEAD_DEBOUNCE_WAIT_MS);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}
function $fb3050f43d946246$var$getStringForKey(key) {
  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;
  return "";
}

// node_modules/@react-aria/selection/dist/useSelectableCollection.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react9 = __toESM(require_react(), 1);
function $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {
  let { selectionManager: manager, keyboardDelegate: delegate, ref, autoFocus = false, shouldFocusWrap = false, disallowEmptySelection = false, disallowSelectAll = false, selectOnFocus = manager.selectionBehavior === "replace", disallowTypeAhead = false, shouldUseVirtualFocus, allowsTabNavigation = false, isVirtualized, scrollRef = ref, linkBehavior = "action" } = options;
  let { direction } = (0, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7)();
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onKeyDown = (e) => {
    if (e.altKey && e.key === "Tab") e.preventDefault();
    if (!ref.current.contains(e.target)) return;
    const navigateToKey = (key, childFocus) => {
      if (key != null) {
        if (manager.isLink(key) && linkBehavior === "selection" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) {
          (0, import_react_dom.flushSync)(() => {
            manager.setFocusedKey(key, childFocus);
          });
          let item = scrollRef.current.querySelector(`[data-key="${CSS.escape(key.toString())}"]`);
          let itemProps = manager.getItemProps(key);
          router.open(item, e, itemProps.href, itemProps.routerOptions);
          return;
        }
        manager.setFocusedKey(key, childFocus);
        if (manager.isLink(key) && linkBehavior === "override") return;
        if (e.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(key);
        else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);
      }
    };
    switch (e.key) {
      case "ArrowDown":
        if (delegate.getKeyBelow) {
          var _delegate_getFirstKey, _delegate_getFirstKey1;
          e.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);
          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowUp":
        if (delegate.getKeyAbove) {
          var _delegate_getLastKey, _delegate_getLastKey1;
          e.preventDefault();
          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);
          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "ArrowLeft":
        if (delegate.getKeyLeftOf) {
          var _delegate_getFirstKey2, _delegate_getLastKey2;
          e.preventDefault();
          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap) nextKey = direction === "rtl" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "first" : "last");
        }
        break;
      case "ArrowRight":
        if (delegate.getKeyRightOf) {
          var _delegate_getLastKey3, _delegate_getFirstKey3;
          e.preventDefault();
          let nextKey = delegate.getKeyRightOf(manager.focusedKey);
          if (nextKey == null && shouldFocusWrap) nextKey = direction === "rtl" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);
          navigateToKey(nextKey, direction === "rtl" ? "last" : "first");
        }
        break;
      case "Home":
        if (delegate.getFirstKey) {
          e.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));
          manager.setFocusedKey(firstKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(firstKey);
          else if (selectOnFocus) manager.replaceSelection(firstKey);
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));
          manager.setFocusedKey(lastKey);
          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === "multiple") manager.extendSelection(lastKey);
          else if (selectOnFocus) manager.replaceSelection(lastKey);
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === "multiple" && disallowSelectAll !== true) {
          e.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {
          e.stopPropagation();
          e.preventDefault();
          manager.clearSelection();
        }
        break;
      case "Tab":
        if (!allowsTabNavigation) {
          if (e.shiftKey) ref.current.focus();
          else {
            let walker = (0, $9bf71ea28793e738$export$2d6ec8fc375ceafa)(ref.current, {
              tabbable: true
            });
            let next;
            let last;
            do {
              last = walker.lastChild();
              if (last) next = last;
            } while (last);
            if (next && !next.contains(document.activeElement)) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(next);
          }
          break;
        }
    }
  };
  let scrollPos = (0, import_react9.useRef)({
    top: 0,
    left: 0
  });
  (0, $e9faafb641e167db$export$90fc3a17d93f704c)(scrollRef, "scroll", isVirtualized ? null : () => {
    scrollPos.current = {
      top: scrollRef.current.scrollTop,
      left: scrollRef.current.scrollLeft
    };
  });
  let onFocus = (e) => {
    if (manager.isFocused) {
      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);
      return;
    }
    if (!e.currentTarget.contains(e.target)) return;
    manager.setFocused(true);
    if (manager.focusedKey == null) {
      let navigateToFirstKey = (key) => {
        if (key != null) {
          manager.setFocusedKey(key);
          if (selectOnFocus) manager.replaceSelection(key);
        }
      };
      let relatedTarget = e.relatedTarget;
      var _manager_lastSelectedKey, _manager_firstSelectedKey;
      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());
      else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());
    } else if (!isVirtualized) {
      scrollRef.current.scrollTop = scrollPos.current.top;
      scrollRef.current.scrollLeft = scrollPos.current.left;
    }
    if (!isVirtualized && manager.focusedKey != null) {
      let element = scrollRef.current.querySelector(`[data-key="${CSS.escape(manager.focusedKey.toString())}"]`);
      if (element) {
        if (!element.contains(document.activeElement)) (0, $7215afc6de606d6b$export$de79e2c695e052f3)(element);
        let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
        if (modality === "keyboard") (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element, {
          containingElement: ref.current
        });
      }
    }
  };
  let onBlur = (e) => {
    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);
  };
  const autoFocusRef = (0, import_react9.useRef)(autoFocus);
  (0, import_react9.useEffect)(() => {
    if (autoFocusRef.current) {
      let focusedKey = null;
      if (autoFocus === "first") focusedKey = delegate.getFirstKey();
      if (autoFocus === "last") focusedKey = delegate.getLastKey();
      let selectedKeys = manager.selectedKeys;
      if (selectedKeys.size) {
        for (let key of selectedKeys) if (manager.canSelectItem(key)) {
          focusedKey = key;
          break;
        }
      }
      manager.setFocused(true);
      manager.setFocusedKey(focusedKey);
      if (focusedKey == null && !shouldUseVirtualFocus) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    }
  }, []);
  let lastFocusedKey = (0, import_react9.useRef)(manager.focusedKey);
  (0, import_react9.useEffect)(() => {
    let modality = (0, $507fabe10e71c6fb$export$630ff653c5ada6a9)();
    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {
      let element = scrollRef.current.querySelector(`[data-key="${CSS.escape(manager.focusedKey.toString())}"]`);
      if (element && (modality === "keyboard" || autoFocusRef.current)) {
        if (!isVirtualized) (0, $2f04cbc44ee30ce0$export$53a0910f038337bd)(scrollRef.current, element);
        if (modality !== "virtual") (0, $2f04cbc44ee30ce0$export$c826860796309d1b)(element, {
          containingElement: ref.current
        });
      }
    }
    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    lastFocusedKey.current = manager.focusedKey;
    autoFocusRef.current = false;
  }, [
    isVirtualized,
    scrollRef,
    manager.focusedKey,
    manager.isFocused,
    ref
  ]);
  let handlers = {
    onKeyDown,
    onFocus,
    onBlur,
    onMouseDown(e) {
      if (scrollRef.current === e.target)
        e.preventDefault();
    }
  };
  let { typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({
    keyboardDelegate: delegate,
    selectionManager: manager
  });
  if (!disallowTypeAhead) handlers = (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(typeSelectProps, handlers);
  let tabIndex;
  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;
  return {
    collectionProps: {
      ...handlers,
      tabIndex
    }
  };
}

// node_modules/@react-aria/selection/dist/useSelectableItem.mjs
var import_react10 = __toESM(require_react(), 1);
function $880e95eb8b93ba9a$export$ecf600387e221c37(options) {
  let { selectionManager: manager, key, ref, shouldSelectOnPressUp, shouldUseVirtualFocus, focus, isDisabled, onAction, allowsDifferentPressOrigin, linkBehavior = "action" } = options;
  let router = (0, $ea8dcbcb9ea1b556$export$9a302a45f65d0572)();
  let onSelect = (e) => {
    if (e.pointerType === "keyboard" && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);
    else {
      if (manager.selectionMode === "none") return;
      if (manager.isLink(key)) {
        if (linkBehavior === "selection") {
          let itemProps2 = manager.getItemProps(key);
          router.open(ref.current, e, itemProps2.href, itemProps2.routerOptions);
          manager.setSelectedKeys(manager.selectedKeys);
          return;
        } else if (linkBehavior === "override" || linkBehavior === "none") return;
      }
      if (manager.selectionMode === "single") {
        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);
        else manager.replaceSelection(key);
      } else if (e && e.shiftKey) manager.extendSelection(key);
      else if (manager.selectionBehavior === "toggle" || e && ((0, $feb5ffebff200149$export$16792effe837dba3)(e) || e.pointerType === "touch" || e.pointerType === "virtual"))
        manager.toggleSelection(key);
      else manager.replaceSelection(key);
    }
  };
  (0, import_react10.useEffect)(() => {
    let isFocused = key === manager.focusedKey;
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus) {
      if (focus) focus();
      else if (document.activeElement !== ref.current) (0, $6a99195332edec8b$export$80f3e147d781571c)(ref.current);
    }
  }, [
    ref,
    key,
    manager.focusedKey,
    manager.childFocusStrategy,
    manager.isFocused,
    shouldUseVirtualFocus
  ]);
  isDisabled = isDisabled || manager.isDisabled(key);
  let itemProps = {};
  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {
    tabIndex: key === manager.focusedKey ? 0 : -1,
    onFocus(e) {
      if (e.target === ref.current) manager.setFocusedKey(key);
    }
  };
  else if (isDisabled) itemProps.onMouseDown = (e) => {
    e.preventDefault();
  };
  let isLinkOverride = manager.isLink(key) && linkBehavior === "override";
  let hasLinkAction = manager.isLink(key) && linkBehavior !== "selection" && linkBehavior !== "none";
  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;
  let allowsActions = (onAction || hasLinkAction) && !isDisabled;
  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === "replace" ? !allowsSelection : !allowsSelection || manager.isEmpty);
  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === "replace";
  let hasAction = hasPrimaryAction || hasSecondaryAction;
  let modality = (0, import_react10.useRef)(null);
  let longPressEnabled = hasAction && allowsSelection;
  let longPressEnabledOnPressStart = (0, import_react10.useRef)(false);
  let hadPrimaryActionOnPressStart = (0, import_react10.useRef)(false);
  let performAction = (e) => {
    if (onAction) onAction();
    if (hasLinkAction) {
      let itemProps2 = manager.getItemProps(key);
      router.open(ref.current, e, itemProps2.href, itemProps2.routerOptions);
    }
  };
  let itemPressProps = {};
  if (shouldSelectOnPressUp) {
    itemPressProps.onPressStart = (e) => {
      modality.current = e.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      if (e.pointerType === "keyboard" && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);
    };
    if (!allowsDifferentPressOrigin) itemPressProps.onPress = (e) => {
      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== "mouse") {
        if (e.pointerType === "keyboard" && !$880e95eb8b93ba9a$var$isActionKey()) return;
        performAction(e);
      } else if (e.pointerType !== "keyboard" && allowsSelection) onSelect(e);
    };
    else {
      itemPressProps.onPressUp = hasPrimaryAction ? null : (e) => {
        if (e.pointerType !== "keyboard" && allowsSelection) onSelect(e);
      };
      itemPressProps.onPress = hasPrimaryAction ? performAction : null;
    }
  } else {
    itemPressProps.onPressStart = (e) => {
      modality.current = e.pointerType;
      longPressEnabledOnPressStart.current = longPressEnabled;
      hadPrimaryActionOnPressStart.current = hasPrimaryAction;
      if (allowsSelection && (e.pointerType === "mouse" && !hasPrimaryAction || e.pointerType === "keyboard" && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey()))) onSelect(e);
    };
    itemPressProps.onPress = (e) => {
      if (e.pointerType === "touch" || e.pointerType === "pen" || e.pointerType === "virtual" || e.pointerType === "keyboard" && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === "mouse" && hadPrimaryActionOnPressStart.current) {
        if (hasAction) performAction(e);
        else if (allowsSelection) onSelect(e);
      }
    };
  }
  itemProps["data-key"] = key;
  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;
  let { pressProps, isPressed } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)(itemPressProps);
  let onDoubleClick = hasSecondaryAction ? (e) => {
    if (modality.current === "mouse") {
      e.stopPropagation();
      e.preventDefault();
      performAction(e);
    }
  } : void 0;
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: !longPressEnabled,
    onLongPress(e) {
      if (e.pointerType === "touch") {
        onSelect(e);
        manager.setSelectionBehavior("toggle");
      }
    }
  });
  let onDragStartCapture = (e) => {
    if (modality.current === "touch" && longPressEnabledOnPressStart.current) e.preventDefault();
  };
  let onClick = manager.isLink(key) ? (e) => {
    if (!(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d7).isOpening) e.preventDefault();
  } : void 0;
  return {
    itemProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, longPressEnabled ? longPressProps : {}, {
      onDoubleClick,
      onDragStartCapture,
      onClick
    }),
    isPressed,
    isSelected: manager.isSelected(key),
    isFocused: manager.isFocused && manager.focusedKey === key,
    isDisabled,
    allowsSelection,
    hasAction
  };
}
function $880e95eb8b93ba9a$var$isActionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === "Enter";
}
function $880e95eb8b93ba9a$var$isSelectionKey() {
  let event = window.event;
  return (event === null || event === void 0 ? void 0 : event.key) === " " || (event === null || event === void 0 ? void 0 : event.code) === "Space";
}

// node_modules/@react-aria/selection/dist/ListKeyboardDelegate.mjs
var $2a25aae57d74318e$export$a05409b8bb224a5a = class {
  isDisabled(item) {
    var _item_props;
    return this.disabledBehavior === "all" && (((_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item.key));
  }
  getNextKey(key) {
    key = this.collection.getKeyAfter(key);
    while (key != null) {
      let item = this.collection.getItem(key);
      if (item.type === "item" && !this.isDisabled(item)) return key;
      key = this.collection.getKeyAfter(key);
    }
    return null;
  }
  getPreviousKey(key) {
    key = this.collection.getKeyBefore(key);
    while (key != null) {
      let item = this.collection.getItem(key);
      if (item.type === "item" && !this.isDisabled(item)) return key;
      key = this.collection.getKeyBefore(key);
    }
    return null;
  }
  findKey(key, nextKey, shouldSkip) {
    let item = this.getItem(key);
    if (!item) return null;
    let prevRect = item.getBoundingClientRect();
    do {
      key = nextKey(key);
      item = this.getItem(key);
    } while (item && shouldSkip(prevRect, item.getBoundingClientRect()));
    return key;
  }
  isSameRow(prevRect, itemRect) {
    return prevRect.top === itemRect.top || prevRect.left !== itemRect.left;
  }
  isSameColumn(prevRect, itemRect) {
    return prevRect.left === itemRect.left || prevRect.top !== itemRect.top;
  }
  getKeyBelow(key) {
    if (this.layout === "grid" && this.orientation === "vertical") return this.findKey(key, (key2) => this.getNextKey(key2), this.isSameRow);
    else return this.getNextKey(key);
  }
  getKeyAbove(key) {
    if (this.layout === "grid" && this.orientation === "vertical") return this.findKey(key, (key2) => this.getPreviousKey(key2), this.isSameRow);
    else return this.getPreviousKey(key);
  }
  getNextColumn(key, right) {
    return right ? this.getPreviousKey(key) : this.getNextKey(key);
  }
  getKeyRightOf(key) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical") return this.getNextColumn(key, this.direction === "rtl");
      else return this.findKey(key, (key2) => this.getNextColumn(key2, this.direction === "rtl"), this.isSameColumn);
    } else if (this.orientation === "horizontal") return this.getNextColumn(key, this.direction === "rtl");
    return null;
  }
  getKeyLeftOf(key) {
    if (this.layout === "grid") {
      if (this.orientation === "vertical") return this.getNextColumn(key, this.direction === "ltr");
      else return this.findKey(key, (key2) => this.getNextColumn(key2, this.direction === "ltr"), this.isSameColumn);
    } else if (this.orientation === "horizontal") return this.getNextColumn(key, this.direction === "ltr");
    return null;
  }
  getFirstKey() {
    let key = this.collection.getFirstKey();
    while (key != null) {
      let item = this.collection.getItem(key);
      if ((item === null || item === void 0 ? void 0 : item.type) === "item" && !this.isDisabled(item)) return key;
      key = this.collection.getKeyAfter(key);
    }
    return null;
  }
  getLastKey() {
    let key = this.collection.getLastKey();
    while (key != null) {
      let item = this.collection.getItem(key);
      if (item.type === "item" && !this.isDisabled(item)) return key;
      key = this.collection.getKeyBefore(key);
    }
    return null;
  }
  getItem(key) {
    return key !== null ? this.ref.current.querySelector(`[data-key="${CSS.escape(key.toString())}"]`) : null;
  }
  getKeyPageAbove(key) {
    let menu2 = this.ref.current;
    let item = this.getItem(key);
    if (!item) return null;
    if (!(0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(menu2)) return this.getFirstKey();
    let containerRect = menu2.getBoundingClientRect();
    let itemRect = item.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu2.scrollLeft;
      let pageX = Math.max(0, itemRect.x - containerX + itemRect.width - containerRect.width);
      while (item && itemRect.x - containerX > pageX) {
        key = this.getKeyAbove(key);
        item = key == null ? null : this.getItem(key);
        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu2.scrollTop;
      let pageY = Math.max(0, itemRect.y - containerY + itemRect.height - containerRect.height);
      while (item && itemRect.y - containerY > pageY) {
        key = this.getKeyAbove(key);
        item = key == null ? null : this.getItem(key);
        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
      }
    }
    return key !== null && key !== void 0 ? key : this.getFirstKey();
  }
  getKeyPageBelow(key) {
    let menu2 = this.ref.current;
    let item = this.getItem(key);
    if (!item) return null;
    if (!(0, $cc38e7bd3fc7b213$export$2bb74740c4e19def)(menu2)) return this.getLastKey();
    let containerRect = menu2.getBoundingClientRect();
    let itemRect = item.getBoundingClientRect();
    if (this.orientation === "horizontal") {
      let containerX = containerRect.x - menu2.scrollLeft;
      let pageX = Math.min(menu2.scrollWidth, itemRect.x - containerX - itemRect.width + containerRect.width);
      while (item && itemRect.x - containerX < pageX) {
        key = this.getKeyBelow(key);
        item = key == null ? null : this.getItem(key);
        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
      }
    } else {
      let containerY = containerRect.y - menu2.scrollTop;
      let pageY = Math.min(menu2.scrollHeight, itemRect.y - containerY - itemRect.height + containerRect.height);
      while (item && itemRect.y - containerY < pageY) {
        key = this.getKeyBelow(key);
        item = key == null ? null : this.getItem(key);
        itemRect = item === null || item === void 0 ? void 0 : item.getBoundingClientRect();
      }
    }
    return key !== null && key !== void 0 ? key : this.getLastKey();
  }
  getKeyForSearch(search, fromKey) {
    if (!this.collator) return null;
    let collection = this.collection;
    let key = fromKey || this.getFirstKey();
    while (key != null) {
      let item = collection.getItem(key);
      let substring = item.textValue.slice(0, search.length);
      if (item.textValue && this.collator.compare(substring, search) === 0) return key;
      key = this.getKeyBelow(key);
    }
    return null;
  }
  constructor(...args) {
    if (args.length === 1) {
      let opts = args[0];
      this.collection = opts.collection;
      this.ref = opts.ref;
      this.collator = opts.collator;
      this.disabledKeys = opts.disabledKeys || /* @__PURE__ */ new Set();
      this.disabledBehavior = opts.disabledBehavior || "all";
      this.orientation = opts.orientation;
      this.direction = opts.direction;
      this.layout = opts.layout || "stack";
    } else {
      this.collection = args[0];
      this.disabledKeys = args[1];
      this.ref = args[2];
      this.collator = args[3];
      this.layout = "stack";
      this.orientation = "vertical";
      this.disabledBehavior = "all";
    }
    if (this.layout === "stack" && this.orientation === "vertical") {
      this.getKeyLeftOf = void 0;
      this.getKeyRightOf = void 0;
    }
  }
};

// node_modules/@react-aria/selection/dist/useSelectableList.mjs
var import_react11 = __toESM(require_react(), 1);
function $982254629710d113$export$b95089534ab7c1fd(props) {
  let { selectionManager, collection, disabledKeys, ref, keyboardDelegate } = props;
  let collator = (0, $325a3faab7a68acd$export$a16aca283550c30d)({
    usage: "search",
    sensitivity: "base"
  });
  let disabledBehavior = selectionManager.disabledBehavior;
  let delegate = (0, import_react11.useMemo)(() => keyboardDelegate || new (0, $2a25aae57d74318e$export$a05409b8bb224a5a)({
    collection,
    disabledKeys,
    disabledBehavior,
    ref,
    collator
  }), [
    keyboardDelegate,
    collection,
    disabledKeys,
    ref,
    collator,
    disabledBehavior
  ]);
  let { collectionProps } = (0, $ae20dd8cbca75726$export$d6daf82dcd84e87c)({
    ...props,
    ref,
    selectionManager,
    keyboardDelegate: delegate
  });
  return {
    listProps: collectionProps
  };
}

// node_modules/@nextui-org/use-aria-menu/dist/chunk-PH3KUROQ.mjs
var menuData = /* @__PURE__ */ new WeakMap();
function useMenu(props, state, ref) {
  let { shouldFocusWrap = true, onKeyDown, onKeyUp, ...otherProps } = props;
  if (!props["aria-label"] && !props["aria-labelledby"]) {
    console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  }
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, { labelable: true });
  let { listProps } = $982254629710d113$export$b95089534ab7c1fd({
    ...otherProps,
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    shouldFocusWrap,
    linkBehavior: "override"
  });
  menuData.set(state, {
    onClose: props.onClose,
    onAction: props.onAction
  });
  return {
    menuProps: $3ef42575df84b30b$export$9d1611c77c2fe928(
      domProps,
      { onKeyDown, onKeyUp },
      {
        role: "menu",
        ...listProps,
        onKeyDown: (event) => {
          if (event.key !== "Escape") {
            if (listProps.onKeyDown) {
              listProps.onKeyDown(event);
            }
          }
        }
      }
    )
  };
}

// node_modules/@nextui-org/use-aria-menu/dist/chunk-XMP5YDUN.mjs
function useMenuItem(props, state, ref) {
  var _a, _b;
  let {
    key,
    closeOnSelect,
    isVirtualized,
    "aria-haspopup": hasPopup,
    onPressStart: pressStartProp,
    onPressUp: pressUpProp,
    onPress,
    onPressChange,
    onPressEnd,
    onHoverStart: hoverStartProp,
    onHoverChange,
    onHoverEnd,
    onKeyDown,
    onKeyUp,
    onFocus,
    onFocusChange,
    onBlur,
    onClick
  } = props;
  let isTrigger = !!hasPopup;
  let isDisabled = (_a = props.isDisabled) != null ? _a : state.selectionManager.isDisabled(key);
  let isSelected = (_b = props.isSelected) != null ? _b : state.selectionManager.isSelected(key);
  let data = menuData.get(state);
  let item = state.collection.getItem(key);
  let onClose = props.onClose || data.onClose;
  let router = $ea8dcbcb9ea1b556$export$9a302a45f65d0572();
  let performAction = (e) => {
    var _a2;
    if (isTrigger) {
      return;
    }
    if ((_a2 = item == null ? void 0 : item.props) == null ? void 0 : _a2.onAction) {
      item.props.onAction();
    }
    if (props.onAction) {
      props.onAction(key);
    } else if (data.onAction) {
      data.onAction(key);
    }
    if (e.target instanceof HTMLAnchorElement) {
      router.open(e.target, e, item.props.href, item.props.routerOptions);
    }
  };
  let role = "menuitem";
  if (!isTrigger) {
    if (state.selectionManager.selectionMode === "single") {
      role = "menuitemradio";
    } else if (state.selectionManager.selectionMode === "multiple") {
      role = "menuitemcheckbox";
    }
  }
  let labelId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let descriptionId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let keyboardId = $bdb11010cef70236$export$b4cc09c592e8fdb8();
  let ariaProps = {
    "aria-disabled": isDisabled || void 0,
    role,
    "aria-label": props["aria-label"],
    "aria-labelledby": labelId,
    "aria-describedby": [descriptionId, keyboardId].filter(Boolean).join(" ") || void 0,
    "aria-controls": props["aria-controls"],
    "aria-haspopup": hasPopup,
    "aria-expanded": props["aria-expanded"]
  };
  if (state.selectionManager.selectionMode !== "none" && !isTrigger) {
    ariaProps["aria-checked"] = isSelected;
  }
  if (isVirtualized) {
    ariaProps["aria-posinset"] = item == null ? void 0 : item.index;
    ariaProps["aria-setsize"] = $453cc9f0df89c0a5$export$77d5aafae4e095b2(state.collection);
  }
  let onPressStart = (e) => {
    if (e.pointerType === "keyboard") {
      performAction(e);
    }
    pressStartProp == null ? void 0 : pressStartProp(e);
  };
  let onPressUp = (e) => {
    if (e.pointerType !== "keyboard") {
      setTimeout(() => {
        performAction(e);
      });
      if (!isTrigger && onClose && (closeOnSelect != null ? closeOnSelect : state.selectionManager.selectionMode !== "multiple" || state.selectionManager.isLink(key))) {
        setTimeout(() => {
          onClose == null ? void 0 : onClose();
        });
      }
    }
    pressUpProp == null ? void 0 : pressUpProp(e);
  };
  let { itemProps, isFocused } = $880e95eb8b93ba9a$export$ecf600387e221c37({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    linkBehavior: "none"
  });
  let { pressProps, isPressed } = $f6c31cce2adf654f$export$45712eceda6fad21({
    onPressStart,
    onPress,
    onPressUp,
    onPressChange,
    onPressEnd,
    isDisabled
  });
  let { isHovered, hoverProps } = $6179b936705e76d3$export$ae780daf29e6d456({
    isDisabled,
    onHoverStart(e) {
      if (!$507fabe10e71c6fb$export$b9b3dfddab17db27()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
      hoverStartProp == null ? void 0 : hoverStartProp(e);
    },
    onHoverChange,
    onHoverEnd
  });
  let { keyboardProps } = $46d819fcbaf35654$export$8f71654801c2f7cd({
    onKeyDown: (e) => {
      if (e.repeat) {
        e.continuePropagation();
        return;
      }
      switch (e.key) {
        case " ":
          if (!isDisabled && state.selectionManager.selectionMode === "none" && !isTrigger && closeOnSelect !== false && onClose) {
            onClose();
          }
          break;
        case "Enter":
          if (!isDisabled && closeOnSelect !== false && !isTrigger && onClose) {
            onClose();
          }
          break;
        default:
          if (!isTrigger) {
            e.continuePropagation();
          }
          onKeyDown == null ? void 0 : onKeyDown(e);
          break;
      }
    },
    onKeyUp
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({ onBlur, onFocus, onFocusChange });
  let domProps = $65484d02dcb7eb3e$export$457c3d6518dd4c6f(item.props);
  delete domProps.id;
  let linkProps = $ea8dcbcb9ea1b556$export$7e924b3091a3bd18(item.props);
  return {
    menuItemProps: {
      ...ariaProps,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(
        domProps,
        linkProps,
        isTrigger ? { onFocus: itemProps.onFocus } : itemProps,
        pressProps,
        hoverProps,
        keyboardProps,
        focusProps,
        {
          onClick: $ff5963eb1fccf552$export$e08e3b67e392101e(onClick, pressProps.onClick)
        }
      ),
      tabIndex: itemProps.tabIndex != null ? -1 : void 0
    },
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    keyboardShortcutProps: {
      id: keyboardId
    },
    isHovered,
    isFocused,
    isSelected,
    isPressed,
    isDisabled
  };
}

// node_modules/@nextui-org/use-is-mobile/node_modules/@react-aria/ssr/dist/SSRProvider.mjs
var import_react12 = __toESM(require_react(), 1);
var $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
var $b5e257d569688ac6$var$SSRContext = (0, import_react12.default).createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = (0, import_react12.default).createContext(false);
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled = false) {
  let ctx = (0, import_react12.useContext)($b5e257d569688ac6$var$SSRContext);
  let ref = (0, import_react12.useRef)(null);
  if (ref.current === null && !isDisabled) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, import_react12.default).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = (0, import_react12.useContext)($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix}-${counter}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id = (0, import_react12.default).useId();
  let [didSSR] = (0, import_react12.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix}-${id}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, import_react12.default)["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof (0, import_react12.default)["useSyncExternalStore"] === "function") return (0, import_react12.default)["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return (0, import_react12.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

// node_modules/@nextui-org/use-is-mobile/dist/index.mjs
var MOBILE_SCREEN_WIDTH = 700;
function useIsMobile() {
  let isSSR = $b5e257d569688ac6$export$535bd6ca7f90a273();
  if (isSSR || typeof window === "undefined") {
    return false;
  }
  return window.screen.width <= MOBILE_SCREEN_WIDTH;
}

// node_modules/@nextui-org/menu/dist/chunk-BQCSFB47.mjs
function useMenuItem2(originalProps) {
  var _a, _b;
  const globalContext = useProviderContext();
  const [props, variantProps] = mapPropsVariants(originalProps, menuItem.variantKeys);
  const {
    as,
    item,
    state,
    shortcut,
    description,
    startContent,
    endContent,
    isVirtualized,
    selectedIcon,
    className,
    classNames,
    onAction,
    autoFocus,
    onClick,
    onPress,
    onPressStart,
    onPressUp,
    onPressEnd,
    onPressChange,
    hideSelectedIcon = false,
    isReadOnly = false,
    closeOnSelect,
    onClose,
    ...otherProps
  } = props;
  const disableAnimation = (_b = (_a = originalProps.disableAnimation) != null ? _a : globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _b : false;
  const domRef = (0, import_react13.useRef)(null);
  const Component = as || ((otherProps == null ? void 0 : otherProps.href) ? "a" : "li");
  const shouldFilterDOMProps = typeof Component === "string";
  const { rendered, key } = item;
  const isDisabled = state.disabledKeys.has(key) || originalProps.isDisabled;
  const isSelectable = state.selectionManager.selectionMode !== "none";
  const isMobile = useIsMobile();
  const { isFocusVisible, focusProps } = $f7dceffc5ad7768b$export$4e328f61c538687f({
    autoFocus
  });
  const {
    isHovered,
    isPressed,
    isFocused,
    isSelected,
    menuItemProps,
    labelProps,
    descriptionProps,
    keyboardShortcutProps
  } = useMenuItem(
    {
      key,
      onClose,
      isDisabled,
      onPress,
      onClick,
      onPressStart,
      onPressUp,
      onPressEnd,
      onPressChange,
      "aria-label": props["aria-label"],
      closeOnSelect,
      isVirtualized,
      onAction
    },
    state,
    domRef
  );
  let itemProps = menuItemProps;
  const slots = (0, import_react13.useMemo)(
    () => menuItem({
      ...variantProps,
      isDisabled,
      disableAnimation
    }),
    [objectToDeps(variantProps), isDisabled, disableAnimation]
  );
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  if (isReadOnly) {
    itemProps = removeEvents(itemProps);
  }
  const getItemProps = (props2 = {}) => ({
    ref: domRef,
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(
      isReadOnly ? {} : focusProps,
      filterDOMProps(otherProps, {
        enabled: shouldFilterDOMProps
      }),
      itemProps,
      props2
    ),
    "data-focus": dataAttr(isFocused),
    "data-selectable": dataAttr(isSelectable),
    "data-hover": dataAttr(isMobile ? isHovered || isPressed : isHovered),
    "data-disabled": dataAttr(isDisabled),
    "data-selected": dataAttr(isSelected),
    "data-pressed": dataAttr(isPressed),
    "data-focus-visible": dataAttr(isFocusVisible),
    className: slots.base({ class: clsx(baseStyles, props2.className) })
  });
  const getLabelProps = (props2 = {}) => ({
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(labelProps, props2),
    className: slots.title({ class: classNames == null ? void 0 : classNames.title })
  });
  const getDescriptionProps = (props2 = {}) => ({
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(descriptionProps, props2),
    className: slots.description({ class: classNames == null ? void 0 : classNames.description })
  });
  const getKeyboardShortcutProps = (props2 = {}) => ({
    ...$3ef42575df84b30b$export$9d1611c77c2fe928(keyboardShortcutProps, props2),
    className: slots.shortcut({ class: classNames == null ? void 0 : classNames.shortcut })
  });
  const getSelectedIconProps = (0, import_react13.useCallback)(
    (props2 = {}) => {
      return {
        "aria-hidden": dataAttr(true),
        "data-disabled": dataAttr(isDisabled),
        className: slots.selectedIcon({ class: classNames == null ? void 0 : classNames.selectedIcon }),
        ...props2
      };
    },
    [isDisabled, slots, classNames]
  );
  return {
    Component,
    domRef,
    slots,
    classNames,
    isSelectable,
    isSelected,
    isDisabled,
    rendered,
    shortcut,
    description,
    startContent,
    endContent,
    selectedIcon,
    disableAnimation,
    getItemProps,
    getLabelProps,
    hideSelectedIcon,
    getDescriptionProps,
    getKeyboardShortcutProps,
    getSelectedIconProps
  };
}

// node_modules/@nextui-org/menu/dist/chunk-CQ43W3AP.mjs
var import_react14 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var MenuItem = forwardRef((props, _) => {
  const {
    Component,
    slots,
    classNames,
    rendered,
    shortcut,
    description,
    isSelectable,
    isSelected,
    isDisabled,
    selectedIcon,
    startContent,
    endContent,
    disableAnimation,
    hideSelectedIcon,
    getItemProps,
    getLabelProps,
    getDescriptionProps,
    getKeyboardShortcutProps,
    getSelectedIconProps
  } = useMenuItem2(props);
  const selectedContent = (0, import_react14.useMemo)(() => {
    const defaultIcon = (0, import_jsx_runtime6.jsx)(MenuSelectedIcon, { disableAnimation, isSelected });
    if (typeof selectedIcon === "function") {
      return selectedIcon({ icon: defaultIcon, isSelected, isDisabled });
    }
    if (selectedIcon)
      return selectedIcon;
    return defaultIcon;
  }, [selectedIcon, isSelected, isDisabled, disableAnimation]);
  return (0, import_jsx_runtime6.jsxs)(Component, { ...getItemProps(), children: [
    startContent,
    description ? (0, import_jsx_runtime6.jsxs)("div", { className: slots.wrapper({ class: classNames == null ? void 0 : classNames.wrapper }), children: [
      (0, import_jsx_runtime6.jsx)("span", { ...getLabelProps(), children: rendered }),
      (0, import_jsx_runtime6.jsx)("span", { ...getDescriptionProps(), children: description })
    ] }) : (0, import_jsx_runtime6.jsx)("span", { ...getLabelProps(), children: rendered }),
    shortcut && (0, import_jsx_runtime6.jsx)("kbd", { ...getKeyboardShortcutProps(), children: shortcut }),
    isSelectable && !hideSelectedIcon && (0, import_jsx_runtime6.jsx)("span", { ...getSelectedIconProps(), children: selectedContent }),
    endContent
  ] });
});
MenuItem.displayName = "NextUI.MenuItem";
var menu_item_default = MenuItem;

// node_modules/@react-aria/menu/dist/ar-AE.mjs
var $c0398ad35c3639b7$exports = {};
$c0398ad35c3639b7$exports = {
  "longPressMessage": `     Alt +    `
};

// node_modules/@react-aria/menu/dist/bg-BG.mjs
var $7af657c4165927c3$exports = {};
$7af657c4165927c3$exports = {
  "longPressMessage": `    Alt+  ,    `
};

// node_modules/@react-aria/menu/dist/cs-CZ.mjs
var $d95d4da6d531ab81$exports = {};
$d95d4da6d531ab81$exports = {
  "longPressMessage": `Dlouhm stiskem nebo stisknutm klves Alt + ipka dol otevete nabdku`
};

// node_modules/@react-aria/menu/dist/da-DK.mjs
var $24ebda9c775dca17$exports = {};
$24ebda9c775dca17$exports = {
  "longPressMessage": `Langt tryk eller tryk p Alt + pil ned for at bne menuen`
};

// node_modules/@react-aria/menu/dist/de-DE.mjs
var $743e0dfca6cab1e9$exports = {};
$743e0dfca6cab1e9$exports = {
  "longPressMessage": `Drcken Sie lange oder drcken Sie Alt + Nach-unten, um das Men zu ffnen`
};

// node_modules/@react-aria/menu/dist/el-GR.mjs
var $a2f41026e05f1c84$exports = {};
$a2f41026e05f1c84$exports = {
  "longPressMessage": `    Alt +       `
};

// node_modules/@react-aria/menu/dist/en-US.mjs
var $43b800e97c901737$exports = {};
$43b800e97c901737$exports = {
  "longPressMessage": `Long press or press Alt + ArrowDown to open menu`
};

// node_modules/@react-aria/menu/dist/es-ES.mjs
var $442f5f6ac211e29f$exports = {};
$442f5f6ac211e29f$exports = {
  "longPressMessage": `Mantenga pulsado o pulse Alt + flecha abajo para abrir el men`
};

// node_modules/@react-aria/menu/dist/et-EE.mjs
var $dff280acfeb2d8ac$exports = {};
$dff280acfeb2d8ac$exports = {
  "longPressMessage": `Men avamiseks vajutage pikalt vi vajutage klahve Alt + allanool`
};

// node_modules/@react-aria/menu/dist/fi-FI.mjs
var $51608325613944d7$exports = {};
$51608325613944d7$exports = {
  "longPressMessage": `Avaa valikko painamalla pohjassa tai nppinyhdistelmll Alt + Alanuoli`
};

// node_modules/@react-aria/menu/dist/fr-FR.mjs
var $c4a1b1eabeaa87be$exports = {};
$c4a1b1eabeaa87be$exports = {
  "longPressMessage": `Appuyez de manire prolonge ou appuyez sur Alt+Flche vers le bas pour ouvrir le menu.`
};

// node_modules/@react-aria/menu/dist/he-IL.mjs
var $8c74815cdee18d1b$exports = {};
$8c74815cdee18d1b$exports = {
  "longPressMessage": `     Alt + ArrowDown    `
};

// node_modules/@react-aria/menu/dist/hr-HR.mjs
var $fd0e9ef6a7fe0ec9$exports = {};
$fd0e9ef6a7fe0ec9$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika`
};

// node_modules/@react-aria/menu/dist/hu-HU.mjs
var $a89a74a39eba465a$exports = {};
$a89a74a39eba465a$exports = {
  "longPressMessage": `Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyl gombot a men megnyitshoz`
};

// node_modules/@react-aria/menu/dist/it-IT.mjs
var $edc7c66594a0ae8a$exports = {};
$edc7c66594a0ae8a$exports = {
  "longPressMessage": `Premere a lungo o premere Alt + Freccia gi per aprire il menu`
};

// node_modules/@react-aria/menu/dist/ja-JP.mjs
var $f1ab51510712db52$exports = {};
$f1ab51510712db52$exports = {
  "longPressMessage": ` Alt+`
};

// node_modules/@react-aria/menu/dist/ko-KR.mjs
var $f9b672d9b82fa3d6$exports = {};
$f9b672d9b82fa3d6$exports = {
  "longPressMessage": `  Alt +     `
};

// node_modules/@react-aria/menu/dist/lt-LT.mjs
var $a385f3910feda499$exports = {};
$a385f3910feda499$exports = {
  "longPressMessage": `Nordami atidaryti meniu, nuspaud palaikykite arba paspauskite Alt + ArrowDown.`
};

// node_modules/@react-aria/menu/dist/lv-LV.mjs
var $4f1bde932c441789$exports = {};
$4f1bde932c441789$exports = {
  "longPressMessage": `Lai atvrtu izvlni, turiet nospiestu vai nospiediet taustiu kombinciju Alt + lejupvrst bultia`
};

// node_modules/@react-aria/menu/dist/nb-NO.mjs
var $914a51a8a594d5be$exports = {};
$914a51a8a594d5be$exports = {
  "longPressMessage": `Langt trykk eller trykk Alt + PilNed for  pne menyen`
};

// node_modules/@react-aria/menu/dist/nl-NL.mjs
var $89aaf803103bb500$exports = {};
$89aaf803103bb500$exports = {
  "longPressMessage": `Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen`
};

// node_modules/@react-aria/menu/dist/pl-PL.mjs
var $c685891476dbaaca$exports = {};
$c685891476dbaaca$exports = {
  "longPressMessage": `Nacinij i przytrzymaj lub nacinij klawisze Alt + Strzaka w d, aby otworzy menu`
};

// node_modules/@react-aria/menu/dist/pt-BR.mjs
var $885879b9b10c2959$exports = {};
$885879b9b10c2959$exports = {
  "longPressMessage": `Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu`
};

// node_modules/@react-aria/menu/dist/pt-PT.mjs
var $6b39616688a51692$exports = {};
$6b39616688a51692$exports = {
  "longPressMessage": `Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu`
};

// node_modules/@react-aria/menu/dist/ro-RO.mjs
var $f26362aed63f47e2$exports = {};
$f26362aed63f47e2$exports = {
  "longPressMessage": `Apsai lung sau apsai pe Alt + sgeat n jos pentru a deschide meniul`
};

// node_modules/@react-aria/menu/dist/ru-RU.mjs
var $06cbade644558bf0$exports = {};
$06cbade644558bf0$exports = {
  "longPressMessage": `     Alt +  ,   `
};

// node_modules/@react-aria/menu/dist/sk-SK.mjs
var $0a391ff68f9d59b1$exports = {};
$0a391ff68f9d59b1$exports = {
  "longPressMessage": `Ponuku otvorte dlhm stlaenm alebo stlaenm klvesu Alt + klvesu so pkou nadol`
};

// node_modules/@react-aria/menu/dist/sl-SI.mjs
var $8193cf0e649c7928$exports = {};
$8193cf0e649c7928$exports = {
  "longPressMessage": `Za odprtje menija pritisnite in drite gumb ali pritisnite Alt+puica navzdol`
};

// node_modules/@react-aria/menu/dist/sr-SP.mjs
var $f398debcce5a5c55$exports = {};
$f398debcce5a5c55$exports = {
  "longPressMessage": `Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni`
};

// node_modules/@react-aria/menu/dist/sv-SE.mjs
var $9e9fef000aa4c013$exports = {};
$9e9fef000aa4c013$exports = {
  "longPressMessage": `Hll nedtryckt eller tryck p Alt + pil nedt fr att ppna menyn`
};

// node_modules/@react-aria/menu/dist/tr-TR.mjs
var $c016c8183bbe3d68$exports = {};
$c016c8183bbe3d68$exports = {
  "longPressMessage": `Meny amak iin uzun basn veya Alt + Aa Ok tuuna basn`
};

// node_modules/@react-aria/menu/dist/uk-UA.mjs
var $ca4f6c8462244e62$exports = {};
$ca4f6c8462244e62$exports = {
  "longPressMessage": `      Alt   ,   `
};

// node_modules/@react-aria/menu/dist/zh-CN.mjs
var $2d9960c02ccac927$exports = {};
$2d9960c02ccac927$exports = {
  "longPressMessage": ` Alt + `
};

// node_modules/@react-aria/menu/dist/zh-TW.mjs
var $f1b682a4c8c5631c$exports = {};
$f1b682a4c8c5631c$exports = {
  "longPressMessage": ` Alt+`
};

// node_modules/@react-aria/menu/dist/intlStrings.mjs
var $2cbb7ca666678a14$exports = {};
$2cbb7ca666678a14$exports = {
  "ar-AE": $c0398ad35c3639b7$exports,
  "bg-BG": $7af657c4165927c3$exports,
  "cs-CZ": $d95d4da6d531ab81$exports,
  "da-DK": $24ebda9c775dca17$exports,
  "de-DE": $743e0dfca6cab1e9$exports,
  "el-GR": $a2f41026e05f1c84$exports,
  "en-US": $43b800e97c901737$exports,
  "es-ES": $442f5f6ac211e29f$exports,
  "et-EE": $dff280acfeb2d8ac$exports,
  "fi-FI": $51608325613944d7$exports,
  "fr-FR": $c4a1b1eabeaa87be$exports,
  "he-IL": $8c74815cdee18d1b$exports,
  "hr-HR": $fd0e9ef6a7fe0ec9$exports,
  "hu-HU": $a89a74a39eba465a$exports,
  "it-IT": $edc7c66594a0ae8a$exports,
  "ja-JP": $f1ab51510712db52$exports,
  "ko-KR": $f9b672d9b82fa3d6$exports,
  "lt-LT": $a385f3910feda499$exports,
  "lv-LV": $4f1bde932c441789$exports,
  "nb-NO": $914a51a8a594d5be$exports,
  "nl-NL": $89aaf803103bb500$exports,
  "pl-PL": $c685891476dbaaca$exports,
  "pt-BR": $885879b9b10c2959$exports,
  "pt-PT": $6b39616688a51692$exports,
  "ro-RO": $f26362aed63f47e2$exports,
  "ru-RU": $06cbade644558bf0$exports,
  "sk-SK": $0a391ff68f9d59b1$exports,
  "sl-SI": $8193cf0e649c7928$exports,
  "sr-SP": $f398debcce5a5c55$exports,
  "sv-SE": $9e9fef000aa4c013$exports,
  "tr-TR": $c016c8183bbe3d68$exports,
  "uk-UA": $ca4f6c8462244e62$exports,
  "zh-CN": $2d9960c02ccac927$exports,
  "zh-TW": $f1b682a4c8c5631c$exports
};

// node_modules/@react-aria/menu/dist/useMenuTrigger.mjs
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $168583247155ddda$export$dc9c12ed27dd1b49(props, state, ref) {
  let { type = "menu", isDisabled, trigger = "press" } = props;
  let menuTriggerId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  let { triggerProps, overlayProps } = (0, $628037886ba31236$export$f9d5c8beee7d008d)({
    type
  }, state, ref);
  let onKeyDown = (e) => {
    if (isDisabled) return;
    if (trigger === "longPress" && !e.altKey) return;
    if (ref && ref.current) switch (e.key) {
      case "Enter":
      case " ":
        if (trigger === "longPress") return;
      case "ArrowDown":
        if (!("continuePropagation" in e)) e.stopPropagation();
        e.preventDefault();
        state.toggle("first");
        break;
      case "ArrowUp":
        if (!("continuePropagation" in e)) e.stopPropagation();
        e.preventDefault();
        state.toggle("last");
        break;
      default:
        if ("continuePropagation" in e) e.continuePropagation();
    }
  };
  let stringFormatter = (0, $fca6afa0e843324b$export$f12b703ca79dfbb1)((0, $parcel$interopDefault($2cbb7ca666678a14$exports)), "@react-aria/menu");
  let { longPressProps } = (0, $8a26561d2877236e$export$c24ed0104d07eab9)({
    isDisabled: isDisabled || trigger !== "longPress",
    accessibilityDescription: stringFormatter.format("longPressMessage"),
    onLongPressStart() {
      state.close();
    },
    onLongPress() {
      state.open("first");
    }
  });
  let pressProps = {
    onPressStart(e) {
      if (e.pointerType !== "touch" && e.pointerType !== "keyboard" && !isDisabled)
        state.open(e.pointerType === "virtual" ? "first" : null);
    },
    onPress(e) {
      if (e.pointerType === "touch" && !isDisabled) state.toggle();
    }
  };
  delete triggerProps.onPress;
  return {
    menuTriggerProps: {
      ...triggerProps,
      ...trigger === "press" ? pressProps : longPressProps,
      id: menuTriggerId,
      onKeyDown
    },
    menuProps: {
      ...overlayProps,
      "aria-labelledby": menuTriggerId,
      autoFocus: state.focusStrategy || true,
      onClose: state.close
    }
  };
}

// node_modules/@react-aria/menu/dist/useMenuSection.mjs
function $3e5eb2498db5b506$export$73f7a44322579622(props) {
  let { heading, "aria-label": ariaLabel } = props;
  let headingId = (0, $bdb11010cef70236$export$f680877a34711e37)();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: heading ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a label for the nested group.
      id: headingId,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": ariaLabel,
      "aria-labelledby": heading ? headingId : void 0
    }
  };
}

// node_modules/@react-aria/menu/dist/useSafelyMouseToSubmenu.mjs
var import_react15 = __toESM(require_react(), 1);
var $d275435c250248f8$var$ANGLE_PADDING = Math.PI / 12;

// node_modules/@react-aria/menu/dist/useSubmenuTrigger.mjs
var import_react16 = __toESM(require_react(), 1);

// node_modules/@nextui-org/menu/dist/chunk-SMP2PQ35.mjs
var import_react18 = __toESM(require_react(), 1);

// node_modules/@nextui-org/divider/dist/chunk-LVTFMK47.mjs
function useSeparator(props) {
  let domProps = filterDOMProps(props, {
    enabled: typeof props.elementType === "string"
  });
  let ariaOrientation;
  if (props.orientation === "vertical") {
    ariaOrientation = "vertical";
  }
  if (props.elementType !== "hr") {
    return {
      separatorProps: {
        ...domProps,
        role: "separator",
        "aria-orientation": ariaOrientation
      }
    };
  }
  return { separatorProps: domProps };
}

// node_modules/@nextui-org/divider/dist/chunk-HGQPAK7A.mjs
var import_react17 = __toESM(require_react(), 1);
function useDivider(props) {
  const { as, className, orientation, ...otherProps } = props;
  let Component = as || "hr";
  if (Component === "hr" && orientation === "vertical") {
    Component = "div";
  }
  const { separatorProps } = useSeparator({
    elementType: typeof Component === "string" ? Component : "hr",
    orientation
  });
  const styles = (0, import_react17.useMemo)(
    () => divider({
      orientation,
      className
    }),
    [orientation, className]
  );
  const getDividerProps = (0, import_react17.useCallback)(
    (props2 = {}) => ({
      className: styles,
      role: "separator",
      "data-orientation": orientation,
      ...separatorProps,
      ...otherProps,
      ...props2
    }),
    [styles, orientation, separatorProps, otherProps]
  );
  return { Component, getDividerProps };
}

// node_modules/@nextui-org/divider/dist/chunk-44JHHBS2.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var Divider = forwardRef((props, ref) => {
  const { Component, getDividerProps } = useDivider({ ...props });
  return (0, import_jsx_runtime7.jsx)(Component, { ref, ...getDividerProps() });
});
Divider.displayName = "NextUI.Divider";
var divider_default = Divider;

// node_modules/@nextui-org/menu/dist/chunk-SMP2PQ35.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var MenuSection = forwardRef(
  ({
    item,
    state,
    as,
    variant,
    color,
    disableAnimation,
    onAction,
    closeOnSelect,
    className,
    classNames,
    showDivider = false,
    hideSelectedIcon,
    dividerProps = {},
    itemClasses,
    title,
    ...otherProps
  }, _) => {
    const Component = as || "li";
    const slots = (0, import_react18.useMemo)(() => menuSection(), []);
    const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
    const dividerStyles = clsx(classNames == null ? void 0 : classNames.divider, dividerProps == null ? void 0 : dividerProps.className);
    const { itemProps, headingProps, groupProps } = $3e5eb2498db5b506$export$73f7a44322579622({
      heading: item.rendered,
      "aria-label": item["aria-label"]
    });
    return (0, import_jsx_runtime8.jsxs)(
      Component,
      {
        "data-slot": "base",
        ...$3ef42575df84b30b$export$9d1611c77c2fe928(itemProps, otherProps),
        className: slots.base({ class: baseStyles }),
        children: [
          item.rendered && (0, import_jsx_runtime8.jsx)(
            "span",
            {
              ...headingProps,
              className: slots.heading({ class: classNames == null ? void 0 : classNames.heading }),
              "data-slot": "heading",
              children: item.rendered
            }
          ),
          (0, import_jsx_runtime8.jsxs)(
            "ul",
            {
              ...groupProps,
              className: slots.group({ class: classNames == null ? void 0 : classNames.group }),
              "data-has-title": !!item.rendered,
              "data-slot": "group",
              children: [
                [...item.childNodes].map((node) => {
                  const { key: nodeKey, props: nodeProps } = node;
                  let menuItem2 = (0, import_jsx_runtime8.jsx)(
                    menu_item_default,
                    {
                      classNames: itemClasses,
                      closeOnSelect,
                      color,
                      disableAnimation,
                      hideSelectedIcon,
                      item: node,
                      state,
                      variant,
                      onAction,
                      ...nodeProps
                    },
                    nodeKey
                  );
                  if (node.wrapper) {
                    menuItem2 = node.wrapper(menuItem2);
                  }
                  return menuItem2;
                }),
                showDivider && (0, import_jsx_runtime8.jsx)(
                  divider_default,
                  {
                    as: "li",
                    className: slots.divider({
                      class: dividerStyles
                    }),
                    ...dividerProps
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
);
MenuSection.displayName = "NextUI.MenuSection";
var menu_section_default = MenuSection;

// node_modules/@react-stately/tree/dist/TreeCollection.mjs
var $05ca4cd7c4a5a999$export$863faf230ee2118a = class {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  constructor(nodes, { expandedKeys } = {}) {
    this.keyMap = /* @__PURE__ */ new Map();
    this.iterable = nodes;
    expandedKeys = expandedKeys || /* @__PURE__ */ new Set();
    let visit = (node) => {
      this.keyMap.set(node.key, node);
      if (node.childNodes && (node.type === "section" || expandedKeys.has(node.key))) for (let child of node.childNodes) visit(child);
    };
    for (let node of nodes) visit(node);
    let last;
    let index = 0;
    for (let [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = void 0;
      }
      if (node.type === "item") node.index = index++;
      last = node;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};

// node_modules/@react-stately/selection/dist/Selection.mjs
var $e40ea825a81a3709$export$52baac22726c72bf = class _$e40ea825a81a3709$export$52baac22726c72bf extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof _$e40ea825a81a3709$export$52baac22726c72bf) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
};

// node_modules/@react-stately/selection/node_modules/@react-stately/utils/dist/useControlledState.mjs
var import_react19 = __toESM(require_react(), 1);
function $458b0a5536c1a7cf$export$40bfa8c7b08327152(value, defaultValue, onChange) {
  let [stateValue, setStateValue] = (0, import_react19.useState)(value || defaultValue);
  let isControlledRef = (0, import_react19.useRef)(value !== void 0);
  let isControlled = value !== void 0;
  (0, import_react19.useEffect)(() => {
    let wasControlled = isControlledRef.current;
    if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`);
    isControlledRef.current = isControlled;
  }, [
    isControlled
  ]);
  let currentValue = isControlled ? value : stateValue;
  let setValue = (0, import_react19.useCallback)((value2, ...args) => {
    let onChangeCaller = (value3, ...onChangeArgs) => {
      if (onChange) {
        if (!Object.is(currentValue, value3)) onChange(value3, ...onChangeArgs);
      }
      if (!isControlled)
        currentValue = value3;
    };
    if (typeof value2 === "function") {
      console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320");
      let updateFunction = (oldValue, ...functionArgs) => {
        let interceptedValue = value2(isControlled ? currentValue : oldValue, ...functionArgs);
        onChangeCaller(interceptedValue, ...args);
        if (!isControlled) return interceptedValue;
        return oldValue;
      };
      setStateValue(updateFunction);
    } else {
      if (!isControlled) setStateValue(value2);
      onChangeCaller(value2, ...args);
    }
  }, [
    isControlled,
    currentValue,
    onChange
  ]);
  return [
    currentValue,
    setValue
  ];
}

// node_modules/@react-stately/selection/dist/useMultipleSelectionState.mjs
var import_react20 = __toESM(require_react(), 1);
function $7af3f5b51489e0b5$var$equalSets(setA, setB) {
  if (setA.size !== setB.size) return false;
  for (let item of setA) {
    if (!setB.has(item)) return false;
  }
  return true;
}
function $7af3f5b51489e0b5$export$253fe78d46329472(props) {
  let { selectionMode = "none", disallowEmptySelection, allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = "toggle", disabledBehavior = "all" } = props;
  let isFocusedRef = (0, import_react20.useRef)(false);
  let [, setFocused] = (0, import_react20.useState)(false);
  let focusedKeyRef = (0, import_react20.useRef)(null);
  let childFocusStrategyRef = (0, import_react20.useRef)(null);
  let [, setFocusedKey] = (0, import_react20.useState)(null);
  let selectedKeysProp = (0, import_react20.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [
    props.selectedKeys
  ]);
  let defaultSelectedKeys = (0, import_react20.useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [
    props.defaultSelectedKeys
  ]);
  let [selectedKeys, setSelectedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b08327152)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);
  let disabledKeysProp = (0, import_react20.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let [selectionBehavior, setSelectionBehavior] = (0, import_react20.useState)(selectionBehaviorProp);
  if (selectionBehaviorProp === "replace" && selectionBehavior === "toggle" && typeof selectedKeys === "object" && selectedKeys.size === 0) setSelectionBehavior("replace");
  let lastSelectionBehavior = (0, import_react20.useRef)(selectionBehaviorProp);
  (0, import_react20.useEffect)(() => {
    if (selectionBehaviorProp !== lastSelectionBehavior.current) {
      setSelectionBehavior(selectionBehaviorProp);
      lastSelectionBehavior.current = selectionBehaviorProp;
    }
  }, [
    selectionBehaviorProp
  ]);
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    get isFocused() {
      return isFocusedRef.current;
    },
    setFocused(f) {
      isFocusedRef.current = f;
      setFocused(f);
    },
    get focusedKey() {
      return focusedKeyRef.current;
    },
    get childFocusStrategy() {
      return childFocusStrategyRef.current;
    },
    setFocusedKey(k, childFocusStrategy = "first") {
      focusedKeyRef.current = k;
      childFocusStrategyRef.current = childFocusStrategy;
      setFocusedKey(k);
    },
    selectedKeys,
    setSelectedKeys(keys) {
      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);
    },
    disabledKeys: disabledKeysProp,
    disabledBehavior
  };
}
function $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {
  if (!selection) return defaultValue;
  return selection === "all" ? "all" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);
}

// node_modules/@react-stately/selection/node_modules/@react-stately/collections/dist/Item.mjs
var import_react21 = __toESM(require_react(), 1);
function $c1d7fb2ec91bae71$var$Item(props) {
  return null;
}
$c1d7fb2ec91bae71$var$Item.getCollectionNode = function* getCollectionNode(props, context) {
  let { childItems, title, children } = props;
  let rendered = props.title || props.children;
  let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"] || "";
  if (!textValue && !(context === null || context === void 0 ? void 0 : context.suppressTextValueWarning)) console.warn("<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.");
  yield {
    type: "item",
    props,
    rendered,
    textValue,
    "aria-label": props["aria-label"],
    hasChildNodes: $c1d7fb2ec91bae71$var$hasChildItems(props),
    *childNodes() {
      if (childItems) for (let child of childItems) yield {
        type: "item",
        value: child
      };
      else if (title) {
        let items = [];
        (0, import_react21.default).Children.forEach(children, (child) => {
          items.push({
            type: "item",
            element: child
          });
        });
        yield* items;
      }
    }
  };
};
function $c1d7fb2ec91bae71$var$hasChildItems(props) {
  if (props.hasChildItems != null) return props.hasChildItems;
  if (props.childItems) return true;
  if (props.title && (0, import_react21.default).Children.count(props.children) > 0) return true;
  return false;
}

// node_modules/@react-stately/selection/node_modules/@react-stately/collections/dist/Section.mjs
var import_react22 = __toESM(require_react(), 1);
function $9fc4852771d079eb$var$Section(props) {
  return null;
}
$9fc4852771d079eb$var$Section.getCollectionNode = function* getCollectionNode2(props) {
  let { children, title, items } = props;
  yield {
    type: "section",
    props,
    hasChildNodes: true,
    rendered: title,
    "aria-label": props["aria-label"],
    *childNodes() {
      if (typeof children === "function") {
        if (!items) throw new Error("props.children was a function but props.items is missing");
        for (let item of items) yield {
          type: "item",
          value: item,
          renderer: children
        };
      } else {
        let items2 = [];
        (0, import_react22.default).Children.forEach(children, (child) => {
          items2.push({
            type: "item",
            element: child
          });
        });
        yield* items2;
      }
    }
  };
};

// node_modules/@react-stately/selection/node_modules/@react-stately/collections/dist/CollectionBuilder.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/@react-stately/selection/node_modules/@react-stately/collections/dist/useCollection.mjs
var import_react24 = __toESM(require_react(), 1);

// node_modules/@react-stately/selection/node_modules/@react-stately/collections/dist/getChildNodes.mjs
function $c5a24bc478652b5f$export$1005530eda016c13(node, collection) {
  if (typeof collection.getChildren === "function") return collection.getChildren(node.key);
  return node.childNodes;
}
function $c5a24bc478652b5f$export$fbdeaa6a76694f71(iterable) {
  return $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, 0);
}
function $c5a24bc478652b5f$export$5f3398f8733f90e2(iterable, index) {
  if (index < 0) return void 0;
  let i = 0;
  for (let item of iterable) {
    if (i === index) return item;
    i++;
  }
}
function $c5a24bc478652b5f$export$8c434b3a7a4dad6(collection, a, b) {
  if (a.parentKey === b.parentKey) return a.index - b.index;
  let aAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection, a),
    a
  ];
  let bAncestors = [
    ...$c5a24bc478652b5f$var$getAncestors(collection, b),
    b
  ];
  let firstNonMatchingAncestor = aAncestors.slice(0, bAncestors.length).findIndex((a2, i) => a2 !== bAncestors[i]);
  if (firstNonMatchingAncestor !== -1) {
    a = aAncestors[firstNonMatchingAncestor];
    b = bAncestors[firstNonMatchingAncestor];
    return a.index - b.index;
  }
  if (aAncestors.findIndex((node) => node === b) >= 0) return 1;
  else if (bAncestors.findIndex((node) => node === a) >= 0) return -1;
  return -1;
}
function $c5a24bc478652b5f$var$getAncestors(collection, node) {
  let parents = [];
  while ((node === null || node === void 0 ? void 0 : node.parentKey) != null) {
    node = collection.getItem(node.parentKey);
    parents.unshift(node);
  }
  return parents;
}

// node_modules/@react-stately/selection/dist/SelectionManager.mjs
var $d496c0a20b6e58ec$export$6c8a5aaad13c9852 = class {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(key, childFocusStrategy) {
    if (key == null || this.collection.getItem(key)) this.state.setFocusedKey(key, childFocusStrategy);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(key) {
    if (this.state.selectionMode === "none") return false;
    key = this.getKey(key);
    return this.state.selectedKeys === "all" ? this.canSelectItem(key) : this.state.selectedKeys.has(key);
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty) return false;
    if (this.state.selectedKeys === "all") return true;
    if (this._isSelectAll != null) return this._isSelectAll;
    let allKeys = this.getSelectAllKeys();
    let selectedKeys = this.state.selectedKeys;
    this._isSelectAll = allKeys.every((k) => selectedKeys.has(k));
    return this._isSelectAll;
  }
  get firstSelectedKey() {
    let first = null;
    for (let key of this.state.selectedKeys) {
      let item = this.collection.getItem(key);
      if (!first || item && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item, first) < 0) first = item;
    }
    return first === null || first === void 0 ? void 0 : first.key;
  }
  get lastSelectedKey() {
    let last = null;
    for (let key of this.state.selectedKeys) {
      let item = this.collection.getItem(key);
      if (!last || item && (0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, item, last) > 0) last = item;
    }
    return last === null || last === void 0 ? void 0 : last.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(toKey) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      this.replaceSelection(toKey);
      return;
    }
    toKey = this.getKey(toKey);
    let selection;
    if (this.state.selectedKeys === "all") selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
      toKey
    ], toKey, toKey);
    else {
      let selectedKeys = this.state.selectedKeys;
      let anchorKey = selectedKeys.anchorKey || toKey;
      selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selectedKeys, anchorKey, toKey);
      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) selection.delete(key);
      for (let key of this.getKeyRange(toKey, anchorKey)) if (this.canSelectItem(key)) selection.add(key);
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    let fromItem = this.collection.getItem(from);
    let toItem = this.collection.getItem(to);
    if (fromItem && toItem) {
      if ((0, $c5a24bc478652b5f$export$8c434b3a7a4dad6)(this.collection, fromItem, toItem) <= 0) return this.getKeyRangeInternal(from, to);
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    let keys = [];
    let key = from;
    while (key) {
      let item = this.collection.getItem(key);
      if (item && item.type === "item" || item.type === "cell" && this.allowsCellSelection) keys.push(key);
      if (key === to) return keys;
      key = this.collection.getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    let item = this.collection.getItem(key);
    if (!item)
      return key;
    if (item.type === "cell" && this.allowsCellSelection) return key;
    while (item.type !== "item" && item.parentKey != null) item = this.collection.getItem(item.parentKey);
    if (!item || item.type !== "item") return null;
    return item.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(key) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    key = this.getKey(key);
    if (key == null) return;
    let keys = new (0, $e40ea825a81a3709$export$52baac22726c72bf)(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    if (keys.has(key)) keys.delete(key);
    else if (this.canSelectItem(key)) {
      keys.add(key);
      keys.anchorKey = key;
      keys.currentKey = key;
    }
    if (this.disallowEmptySelection && keys.size === 0) return;
    this.state.setSelectedKeys(keys);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(key) {
    if (this.selectionMode === "none") return;
    key = this.getKey(key);
    if (key == null) return;
    let selection = this.canSelectItem(key) ? new (0, $e40ea825a81a3709$export$52baac22726c72bf)([
      key
    ], key, key) : new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    this.state.setSelectedKeys(selection);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(keys) {
    if (this.selectionMode === "none") return;
    let selection = new (0, $e40ea825a81a3709$export$52baac22726c72bf)();
    for (let key of keys) {
      key = this.getKey(key);
      if (key != null) {
        selection.add(key);
        if (this.selectionMode === "single") break;
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getSelectAllKeys() {
    let keys = [];
    let addKeys = (key) => {
      while (key != null) {
        if (this.canSelectItem(key)) {
          let item = this.collection.getItem(key);
          if (item.type === "item") keys.push(key);
          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== "item")) addKeys((0, $c5a24bc478652b5f$export$fbdeaa6a76694f71)((0, $c5a24bc478652b5f$export$1005530eda016c13)(item, this.collection)).key);
        }
        key = this.collection.getKeyAfter(key);
      }
    };
    addKeys(this.collection.getFirstKey());
    return keys;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    if (!this.isSelectAll && this.selectionMode === "multiple") this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    if (!this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0)) this.state.setSelectedKeys(new (0, $e40ea825a81a3709$export$52baac22726c72bf)());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    if (this.isSelectAll) this.clearSelection();
    else this.selectAll();
  }
  select(key, e) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection) this.toggleSelection(key);
      else this.replaceSelection(key);
    } else if (this.selectionBehavior === "toggle" || e && (e.pointerType === "touch" || e.pointerType === "virtual"))
      this.toggleSelection(key);
    else this.replaceSelection(key);
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys) return true;
    let selectedKeys = this.selectedKeys;
    if (selection.size !== selectedKeys.size) return false;
    for (let key of selection) {
      if (!selectedKeys.has(key)) return false;
    }
    for (let key of selectedKeys) {
      if (!selection.has(key)) return false;
    }
    return true;
  }
  canSelectItem(key) {
    var _item_props;
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(key)) return false;
    let item = this.collection.getItem(key);
    if (!item || (item === null || item === void 0 ? void 0 : (_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || item.type === "cell" && !this.allowsCellSelection) return false;
    return true;
  }
  isDisabled(key) {
    var _this_collection_getItem_props, _this_collection_getItem;
    return this.state.disabledBehavior === "all" && (this.state.disabledKeys.has(key) || !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.isDisabled));
  }
  isLink(key) {
    var _this_collection_getItem_props, _this_collection_getItem;
    return !!((_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : (_this_collection_getItem_props = _this_collection_getItem.props) === null || _this_collection_getItem_props === void 0 ? void 0 : _this_collection_getItem_props.href);
  }
  getItemProps(key) {
    var _this_collection_getItem;
    return (_this_collection_getItem = this.collection.getItem(key)) === null || _this_collection_getItem === void 0 ? void 0 : _this_collection_getItem.props;
  }
  constructor(collection, state, options) {
    this.collection = collection;
    this.state = state;
    var _options_allowsCellSelection;
    this.allowsCellSelection = (_options_allowsCellSelection = options === null || options === void 0 ? void 0 : options.allowsCellSelection) !== null && _options_allowsCellSelection !== void 0 ? _options_allowsCellSelection : false;
    this._isSelectAll = null;
  }
};

// node_modules/@react-stately/tree/dist/useTreeState.mjs
var import_react25 = __toESM(require_react(), 1);
function $875d6693e12af071$export$728d6ba534403756(props) {
  let { onExpandedChange } = props;
  let [expandedKeys, setExpandedKeys] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.expandedKeys ? new Set(props.expandedKeys) : void 0, props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : /* @__PURE__ */ new Set(), onExpandedChange);
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react25.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let tree = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, (0, import_react25.useCallback)((nodes) => new (0, $05ca4cd7c4a5a999$export$863faf230ee2118a)(nodes, {
    expandedKeys
  }), [
    expandedKeys
  ]), null);
  (0, import_react25.useEffect)(() => {
    if (selectionState.focusedKey != null && !tree.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
  }, [
    tree,
    selectionState.focusedKey
  ]);
  let onToggle = (key) => {
    setExpandedKeys($875d6693e12af071$var$toggleKey(expandedKeys, key));
  };
  return {
    collection: tree,
    expandedKeys,
    disabledKeys,
    toggleKey: onToggle,
    setExpandedKeys,
    selectionManager: new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(tree, selectionState)
  };
}
function $875d6693e12af071$var$toggleKey(set, key) {
  let res = new Set(set);
  if (res.has(key)) res.delete(key);
  else res.add(key);
  return res;
}

// node_modules/@nextui-org/menu/dist/chunk-BA3PRXRG.mjs
var import_react26 = __toESM(require_react(), 1);
function useMenu2(props) {
  var _a;
  const globalContext = useProviderContext();
  const {
    as,
    ref,
    variant,
    color,
    children,
    disableAnimation = (_a = globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _a : false,
    onAction,
    closeOnSelect,
    itemClasses,
    className,
    state: propState,
    topContent,
    bottomContent,
    hideEmptyContent = false,
    hideSelectedIcon = false,
    emptyContent = "No items.",
    menuProps: userMenuProps,
    onClose,
    classNames,
    ...otherProps
  } = props;
  const Component = as || "ul";
  const domRef = useDOMRef(ref);
  const shouldFilterDOMProps = typeof Component === "string";
  const innerState = $875d6693e12af071$export$728d6ba534403756({ ...otherProps, ...userMenuProps, children });
  const state = propState || innerState;
  const { menuProps } = useMenu({ ...otherProps, ...userMenuProps }, state, domRef);
  const slots = (0, import_react26.useMemo)(() => menu({ className }), [className]);
  const baseStyles = clsx(classNames == null ? void 0 : classNames.base, className);
  const getBaseProps = (props2 = {}) => {
    return {
      ref: domRef,
      "data-slot": "base",
      className: slots.base({ class: baseStyles }),
      ...filterDOMProps(otherProps, {
        enabled: shouldFilterDOMProps
      }),
      ...props2
    };
  };
  const getListProps = (props2 = {}) => {
    return {
      "data-slot": "list",
      className: slots.list({ class: classNames == null ? void 0 : classNames.list }),
      ...menuProps,
      ...props2
    };
  };
  const getEmptyContentProps = (props2 = {}) => {
    return {
      children: emptyContent,
      className: slots.emptyContent({ class: classNames == null ? void 0 : classNames.emptyContent }),
      ...props2
    };
  };
  return {
    Component,
    state,
    variant,
    color,
    disableAnimation,
    onAction,
    onClose,
    topContent,
    bottomContent,
    closeOnSelect,
    className,
    itemClasses,
    getBaseProps,
    getListProps,
    hideEmptyContent,
    hideSelectedIcon,
    getEmptyContentProps
  };
}

// node_modules/@nextui-org/menu/dist/chunk-V6B7KTCO.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
function Menu(props, ref) {
  const {
    Component,
    state,
    closeOnSelect,
    color,
    disableAnimation,
    hideSelectedIcon,
    hideEmptyContent,
    variant,
    onClose,
    onAction,
    topContent,
    bottomContent,
    itemClasses,
    getBaseProps,
    getListProps,
    getEmptyContentProps
  } = useMenu2({ ...props, ref });
  const content = (0, import_jsx_runtime9.jsxs)(Component, { ...getListProps(), children: [
    !state.collection.size && !hideEmptyContent && (0, import_jsx_runtime9.jsx)("li", { children: (0, import_jsx_runtime9.jsx)("div", { ...getEmptyContentProps() }) }),
    [...state.collection].map((item) => {
      const itemProps = {
        closeOnSelect,
        color,
        disableAnimation,
        item,
        state,
        variant,
        onClose,
        onAction,
        hideSelectedIcon,
        ...item.props
      };
      if (item.type === "section") {
        return (0, import_jsx_runtime9.jsx)(menu_section_default, { ...itemProps, itemClasses }, item.key);
      }
      let menuItem2 = (0, import_jsx_runtime9.jsx)(menu_item_default, { ...itemProps, classNames: itemClasses }, item.key);
      if (item.wrapper) {
        menuItem2 = item.wrapper(menuItem2);
      }
      return menuItem2;
    })
  ] });
  return (0, import_jsx_runtime9.jsxs)("div", { ...getBaseProps(), children: [
    topContent,
    content,
    bottomContent
  ] });
}
var menu_default = forwardRef(Menu);
Menu.displayName = "NextUI.Menu";

// node_modules/@nextui-org/menu/dist/chunk-LRDIO3JU.mjs
var MenuItemBase = $c1d7fb2ec91bae71$export$6d08773d2e66f8f2;
var menu_item_base_default = MenuItemBase;

// node_modules/@nextui-org/dropdown/dist/chunk-SXHEBZUY.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function DropdownMenu(props, ref) {
  const { getMenuProps } = useDropdownContext();
  return (0, import_jsx_runtime10.jsx)(popover_content_default, { children: (0, import_jsx_runtime10.jsx)($9bf71ea28793e738$export$20e40289641fbbb6, { contain: true, restoreFocus: true, children: (0, import_jsx_runtime10.jsx)(menu_default, { ...getMenuProps(props, ref) }) }) });
}
var dropdown_menu_default = forwardRef(DropdownMenu);
DropdownMenu.displayName = "NextUI.DropdownMenu";

// node_modules/@nextui-org/dropdown/dist/chunk-63RZRIL7.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var DropdownTrigger = forwardRef((props, _) => {
  const { getMenuTriggerProps } = useDropdownContext();
  const { children, ...otherProps } = props;
  return (0, import_jsx_runtime11.jsx)(popover_trigger_default, { ...getMenuTriggerProps(otherProps), children });
});
DropdownTrigger.displayName = "NextUI.DropdownTrigger";
var dropdown_trigger_default = DropdownTrigger;

// node_modules/@react-stately/menu/dist/useMenuTriggerState.mjs
var import_react27 = __toESM(require_react(), 1);
function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {
  let overlayTriggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react27.useState)(null);
  let [expandedKeysStack, setExpandedKeysStack] = (0, import_react27.useState)([]);
  let closeAll = () => {
    setExpandedKeysStack([]);
    overlayTriggerState.close();
  };
  let openSubmenu = (triggerKey, level) => {
    setExpandedKeysStack((oldStack) => {
      if (level > oldStack.length) return oldStack;
      return [
        ...oldStack.slice(0, level),
        triggerKey
      ];
    });
  };
  let closeSubmenu = (triggerKey, level) => {
    setExpandedKeysStack((oldStack) => {
      let key = oldStack[level];
      if (key === triggerKey) return oldStack.slice(0, level);
      else return oldStack;
    });
  };
  return {
    focusStrategy,
    ...overlayTriggerState,
    open(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.open();
    },
    toggle(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.toggle();
    },
    close() {
      closeAll();
    },
    expandedKeysStack,
    openSubmenu,
    closeSubmenu
  };
}

// node_modules/@react-stately/menu/dist/useSubmenuTriggerState.mjs
var import_react28 = __toESM(require_react(), 1);

// node_modules/@nextui-org/dropdown/dist/chunk-IBACTBRQ.mjs
var import_react29 = __toESM(require_react(), 1);
function useDropdown(props) {
  var _a;
  const globalContext = useProviderContext();
  const {
    as,
    triggerRef: triggerRefProp,
    isOpen,
    defaultOpen,
    onOpenChange,
    isDisabled,
    type = "menu",
    trigger = "press",
    placement = "bottom",
    closeOnSelect = true,
    shouldBlockScroll = true,
    classNames: classNamesProp,
    disableAnimation = (_a = globalContext == null ? void 0 : globalContext.disableAnimation) != null ? _a : false,
    onClose,
    className,
    ...otherProps
  } = props;
  const Component = as || "div";
  const triggerRef = (0, import_react29.useRef)(null);
  const menuTriggerRef = triggerRefProp || triggerRef;
  const menuRef = (0, import_react29.useRef)(null);
  const popoverRef = (0, import_react29.useRef)(null);
  const state = $a28c903ee9ad8dc5$export$79fefeb1c2091ac3({
    trigger,
    isOpen,
    defaultOpen,
    onOpenChange: (isOpen2) => {
      onOpenChange == null ? void 0 : onOpenChange(isOpen2);
      if (!isOpen2) {
        onClose == null ? void 0 : onClose();
      }
    }
  });
  const { menuTriggerProps, menuProps } = $168583247155ddda$export$dc9c12ed27dd1b49(
    { type, trigger, isDisabled },
    state,
    menuTriggerRef
  );
  const classNames = (0, import_react29.useMemo)(
    () => dropdown({
      className
    }),
    [className]
  );
  const onMenuAction = (menuCloseOnSelect) => {
    if (menuCloseOnSelect !== void 0 && !menuCloseOnSelect) {
      return;
    }
    if (closeOnSelect) {
      state.close();
    }
  };
  const getPopoverProps = (props2 = {}) => {
    const popoverProps = $3ef42575df84b30b$export$9d1611c77c2fe928(otherProps, props2);
    return {
      state,
      placement,
      ref: popoverRef,
      disableAnimation,
      shouldBlockScroll,
      scrollRef: menuRef,
      triggerRef: menuTriggerRef,
      ...popoverProps,
      classNames: {
        ...classNamesProp,
        ...props2.classNames,
        content: clsx(classNames, classNamesProp == null ? void 0 : classNamesProp.content, props2.className)
      }
    };
  };
  const getMenuTriggerProps = (originalProps = {}, _ref = null) => {
    const { onPress, onPressStart, ...otherMenuTriggerProps } = menuTriggerProps;
    return {
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(otherMenuTriggerProps, { isDisabled }, originalProps),
      ref: mergeRefs(_ref, triggerRef)
    };
  };
  const getMenuProps = (props2, _ref = null) => {
    return {
      ref: mergeRefs(_ref, menuRef),
      menuProps,
      closeOnSelect,
      ...$3ef42575df84b30b$export$9d1611c77c2fe928(props2, {
        onAction: (key) => {
          var _a2, _b;
          const item = (_a2 = props2 == null ? void 0 : props2.children) == null ? void 0 : _a2.find((item2) => item2.key === key);
          if (((_b = item == null ? void 0 : item.props) == null ? void 0 : _b.closeOnSelect) === false) {
            onMenuAction(false);
            return;
          }
          onMenuAction(props2 == null ? void 0 : props2.closeOnSelect);
        },
        onClose: state.close
      })
    };
  };
  return {
    Component,
    menuRef,
    menuProps,
    classNames,
    closeOnSelect,
    onClose: state.close,
    autoFocus: state.focusStrategy || true,
    disableAnimation,
    getPopoverProps,
    getMenuProps,
    getMenuTriggerProps
  };
}

// node_modules/@nextui-org/dropdown/dist/chunk-HKWRQVCY.mjs
var import_react30 = __toESM(require_react(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var Dropdown = (props) => {
  const { children, ...otherProps } = props;
  const context = useDropdown(otherProps);
  const [menuTrigger, menu2] = import_react30.default.Children.toArray(children);
  return (0, import_jsx_runtime12.jsx)(DropdownProvider, { value: context, children: (0, import_jsx_runtime12.jsxs)(popover_default, { ...context.getPopoverProps(), children: [
    menuTrigger,
    menu2
  ] }) });
};
Dropdown.displayName = "NextUI.Dropdown";
var dropdown_default = Dropdown;
export {
  dropdown_default as Dropdown,
  menu_item_base_default as DropdownItem,
  dropdown_menu_default as DropdownMenu,
  menu_section_base_default as DropdownSection,
  dropdown_trigger_default as DropdownTrigger,
  useDropdown
};
//# sourceMappingURL=@nextui-org_dropdown.js.map
